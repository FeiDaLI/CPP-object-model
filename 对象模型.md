<h4 id="5dc99f6e">问题</h4>
<h5 id="039eade7">关于对象：</h5>
**<font style="color:#db7800;">C语言和C++区别是什么？</font>**

**<font style="color:#db7800;">C++封装后的布局成本是什么？C++对象数据成员和成员函数(虚拟和非虚拟)的空间和访问成本是什么？虚基类的开销是什么？多重继承的开销是什么？</font>**

**<font style="color:#db7800;">C++槽位对象模型是什么？表格驱动对象模型是什么？现在使用的对象模型是什么？一个类的内存大小是什么？</font>**

**<font style="color:#db7800;">什么是菱形继承问题？虚拟继承如何解决菱形继承问题的？(如何解决，对象构造顺序）</font>**

**<font style="color:#db7800;">什么是简单的继承模型？什么是指针复制的方法？虚继承是如何实现的？</font>**

**<font style="color:#db7800;">struct和class的使用？什么是多态切片问题，如何解决？如何理解指针cast？</font>**

<h5 id="92ecb13c">构造函数和拷贝构造函数：</h5>
**<font style="color:#db7800;">什么是隐式类型转换,有什么问题,如何解决？</font>**

**<font style="color:#db7800;">什么情况下会生成默认构造函数,它的操作是什么？</font>**

**<font style="color:#db7800;">派生类的默认构造函数什么时候会生成(不派生也没有虚函数的类,派生的类,有虚函数的类,有虚继承的类)?</font>****<font style="color:#d1a300;">哪3种情况会调用拷贝构造函数？</font>****<font style="color:#db7800;">什么时候会生成一个默认的拷贝构造函数？什么是bitwise copy?对象按值传递和按引用传递有什么不同？什么是返回值优化？</font>**

<h5 id="ba88b217">Function语义学</h5>
**<font style="color:#db7800;">非静态数据成员/函数的地址分别表示什么？this指针的作用是什么？指向成员函数的指针是什么（静态，非静态，虚函数）？inline的副作用是什么（2个）</font>**

<h4 id="40185fb0">思考：</h4>
<h5 id="5d83ee40">C++对象模型中，C++静态成员变量也是存在静态存储区（bss或data段）吗？</h5>
是的。未初始化的静态成员变量存储在`.bss`段，程序启动时会被自动初始化为零。已初始化的静态成员变量存储在`.data`段，初始值在编译时确定。

<h5 id="9a533b05">**为什么C++不使用槽位对象模型或者表格驱动对象模型？**</h5>
<h5 id="5ecdb83e">为什么会有菱形继承？直接避免这种情况不就好了吗？</h5>
<h1 id="eeeac8e8">关于对象</h1>
<h4 id="c29f4610">C语言和C++对比</h4>
⭐

关联知识点：C和C语言区别

**<font style="color:#db7800;">（联系嵌入式C语言）</font>**

（1）C 语言对硬件的直接访问能力，并且编译后的代码通常非常紧凑，运行效率高。 程序性编程：C 主要支持过程式编程。

（2）C++ 面向对象：C++ 引入了类（class）的概念，允许开发者定义抽象数据类型（ADT），并通过继承、多态等特性来构建复杂的类层次结构。 <u>模板（补充）：</u>C++ 模板提供了一种泛型编程的能力，使得我们可以编写能够处理多种数据类型的代码，比如容器类或者算法，而不需要针对每种类型都写一套特定的实现。

<h4 id="f42c2f72">加上封装后的布局成本</h4>
⭐

关联知识点：

内存布局

<u>（1）数据成员 </u>

<u>空间成本：如果只包含简单的数据成员，那么这些数据成员会直接存储在每个对象实例中，就像C中的struct一样。类不会比等效的C struct更耗费内存。</u>

<u>访问成本：对于非虚成员函数和内联函数，访问数据成员的时间开销通常是微不足道的，因为编译器可以优化这些调用，类似于直接访问结构体成员。</u>

<u>（2）成员函数</u>

<u>空间成本：成员函数并不存储在每个对象实例中。它们存储在代码段，并且每个函数只有一个副本，无论创建了多少个类的对象。这意味着成员函数的存在并不会增加每个对象的大小。</u>

<u>执行期绑定：当使用</u>**<u>非虚拟成员函数</u>**<u>时，函数调用可以在编译时确定，与普通函数调用没有区别。但如果成</u>**<u>员函数被声明为virtual</u>**<u>，则会引入运行时多态性，需要额外的间接跳转来决定具体调用哪个派生类的函数。这涉及到一个虚函数表（vtable）和指向这个表的指针，导致一定的性能开销。</u>

<u>内联函数：如果成员函数被定义为inline，编译器可以选择将其展开到调用点，以减少函数调用开销。但是如果该内联函数在一个模块中有多个定义，可能会导致每个模块都生成一份拷贝，增加了代码体积但不增加运行时开销。</u>

<u>（3）虚拟基类与多重继承</u>

<u>虚拟基类：当基类在继承层次中多次出现，并且你希望确保只有一个共享实例时，可以使用虚拟基类。这会在子类对象中引入一些额外的数据结构来支持单一实例共享，从而可能略微增加对象的大小。</u>

<u>多重继承：在多重继承的情况下，特别是当有复杂的转换发生时（比如从派生类向其中一个基类进行类型转换），编译器需要维护一些额外的信息来正确处理这种情况，这也可能导致一定程度的性能损失。</u>

<h4 id="eeb443b0">C++槽位对象模型(未使用)</h4>
<u>C++中，有两种class data members: static和nonstatic,以及三种class member functions: static、nonstatic和 virtual。</u>

<u>该模型的基本思想是将类的每个成员(无论是数据成员还是函数成员)都分配一个槽位（slot），并且这些槽位按照成员在类中声明的顺序排列。槽位可以看作是指向成员的一个指针或者索引。槽位按照成员在类定义中的声明顺序依次排列。</u>

<u>（1）</u>**<u>统一处理:</u>**<u>不论是数据成员还是函数成员，都采用相同的处理方式，通过槽位来访问。简化了编译器的设计，因为不需要区分不同类型的成员。</u>

<u>（2）</u>**<u>间接访问：</u>**<u>由于每个成员都有自己的槽位，因此访问成员时需要通过槽位进行间接访问。对于数据成员来说，需要额外的一层指针解引用；对于函数成员来说，调用函数时也需要通过一个中间步骤来查找实际的函数地址。</u>

![](https://cdn.nlark.com/yuque/0/2025/png/45533403/1742810993654-35ff8da3-bccd-4654-a002-4c4b46bf8a44.png)

<h4 id="ccbfcd89">表格驱动对象模型(未使用)</h4>
<u>在这种模型中，所有与成员相关的信息被提取出来，并且存储在两个独立的表中： 一个是数据成员表，另一个是成员函数表。每个类对象则包含指向这两个表的指针。</u>

<u>数据成员表直接持有类的所有数据成员的实际值。数据成员按照它们在类中声明的顺序排列在这个表中。当程序需要访问某个数据成员时，它会通过类对象中的指针找到对应的数据成员表，然后根据成员的位置索引直接读取或写入数据。</u>

<u>成员函数表是一系列的槽位（slots），每个槽位包含一个指向实际成员函数的指针。这些槽位同样按照成员函数在类中声明的顺序排列。当调用一个成员函数时，程序会通过类对象中的指针找到对应的成员函数表，然后根据函数的位置索引找到正确的函数指针并执行该函数。</u>

<u>类对象本身主要包含两个指针，分别指向数据成员表和成员函数表。类对象只包含两个指针，因此它的大小固定，不会随着成员数量的变化而变化。无论类有多少个成员，所有的类对象都有一致的结构，即都是两个指针。</u>

![](https://cdn.nlark.com/yuque/0/2025/png/45533403/1742810993618-3179c6a0-a5d2-499c-827b-8646215f592a.png)

<h4 id="adb781ac">C++ 对象模型</h4>
⭐

关联知识点：static关键字

<u>（1）数据成员</u>

<u>非静态数据成员直接存储在每个类对象（class object）内部。当创建一个类的对象时，这些数据成员会作为对象的一部分分配在内存中。由于这些数据成员直接位于对象内部，因此可以直接通过对象指针或引用访问它们，这提供了高效的访问速度。</u>

<u>静态数据成员被存储在所有类对象之外的一个单独区域。无论创建了多少个类对象，静态数据成员只有一个实例，并且所有对象共享这个实例。静态数据成员可以通过类名或对象名来访问，但它并不属于单个对象，而是整个类的一部分。</u>

<u>（2）成员函数</u>

<u>无论是静态还是非静态成员函数，都不存储在类对象内部。成员函数代码通常存放在程序的代码段中，每个函数只有一个副本。成员函数通过对象调用时，编译器会生成相应的调用指令。对于非虚拟成员函数，调用是直接的；对于虚拟成员函数，则需要通过虚函数表（vtable）进行间接调用。</u>

<u>（3）虚函数 </u>

<u>虚函数表 (vtable)：每个包含虚拟函数的类都会有一个对应的虚函数表。虚函数表是一个指针数组，其中每个元素指向一个具体的虚函数实现。</u>

<u>虚函数指针 (vptr)：每个含有虚函数的对象都有一个隐藏的指针（通常称为vptr），指向其类的虚函数表。这样，在运行时可以动态地决定调用哪个版本的虚函数。</u>

<u>RTTI ：虚函数表的第一个槽位通常用于存放类型信息(type_info)，以支持运行时类型识别(RTTI)。</u>

![](https://cdn.nlark.com/yuque/0/2025/png/45533403/1742810993614-e73ebbc7-3950-46e8-8d3b-477b97fff52b.png)

**类对象的内存布局**

一个类对象所需的内存大小包括：非静态数据成员的总和大小。由于对齐需求而填充的空间（可能存在于成员之间或集合体边界）。支持虚函数的额外开销(通常是虚函数表指针)。

<h5 id="616f3f9a">**<u>虚函数表（vtable）</u>**</h5>
<u>虚函数表(vtable)是一个静态数组，每个元素存储了指向类中虚函数的指针。每个包含虚函数的类都有一个对应的vtable。vtable是在编译时生成的，并且对于每个类来说是唯一的。</u>

例如假设有以下类：

```cpp
class Base {
public:
virtual void func1(){/* ... */}
virtual void func2(){/* ... */}
};
```

编译器会为 Base 类生成一个vtable，可能类似于：

```cpp
// vtable for Base
void (Base::*vtable[2])() = {
    &Base::func1,
    &Base::func2
    };
```

<h5 id="6065958e">**虚函数表指针（vptr）**</h5>
<u>每个包含虚函数的对象都会有一个额外的成员变量，称为虚函数表指针（vptr）。vptr是一个指向相应类的vtable的指针。vptr是在运行时动态分配的，并且每个对象都有自己的vptr。</u>

例如，对于 Base 类的对象，其内存布局可能是这样的：

```cpp
struct Base {
void (*vptr)[];  // 指向 Base 的 vtable
// 其他数据成员
};
```

C++中虚拟成员函数是实现多态的关键机制。当一个成员函数被声明为virtual时，它可以在派生类中被重写，并且通过基类指针或引用调用时，会根据实际对象的类型来决定调用哪个版本的函数。

假设normalize()是一个虚拟成员函数，那么以下的调用：

```cpp
ptr->normalize();
```

会被内部转换为：

```cpp
(*ptr->vptr[1])(ptr);
```

vptr 是编译器生成的一个指向虚函数表的指针。每个包含或继承了至少一个虚拟函数的对象都会有一个这样的指针。1 是虚函数表中的索引值，对应于normalize()函数的位置。

第二个 ptr 表示 this 指针，即当前对象的地址。

<h5 id="ff935ae4">**虚函数的代价**</h5>
虚拟表指针(vptr)：每个对象都会有一个虚拟表指针，会增加对象的大小。如每个 Point 对象会多一个指针的大小(通常是4字节)。

构造函数的膨胀：构造函数需要额外的代码来初始化虚拟表指针。

合成的拷贝构造函数和拷贝赋值运算符：编译器会合成这些函数，因为默认的位复制操作可能对虚拟表指针带来非法设定。

构造函数的内部膨胀

```cpp
Point* Point::Point(Point* this, float x, float y) : _x(x), _y(y) {
    // 设置对象的虚拟表指针(vptr)
    this->__vptr_Point = _vtbl_Point;
// 扩展成员初始化列表
this->_x = x;
this->_y = y;
// 返回 this 对象
return this;
}
```

拷贝构造函数的内部合成

```cpp
inline Point* Point::Point(Point* this, const Point& rhs) {
    // 设置对象的虚拟表指针(vptr)
    this->__vptr_Point = _vtbl_Point;
    // 将 rhs 坐标中的连续位拷贝到 this 对象
    this->_x = rhs._x;
    this->_y = rhs._y;
    // 返回 this 对象
    return this;
}
```

<h4 id="4cbf5b88">加上继承</h4>
C++的继承可以是单继承，多重继承或者虚拟继承，以及这些机制对对象布局和访问效率的影响。

**单继承**：<u>C++允许一个派生类(derived class)继承自一个基类(base class)。</u>

**多重继承：**<u>C++也支持多重继承，即一个类可以继承自多个基类。</u>

**虚拟继承**

<u>虚拟继承用于解决多重继承中可能出现的“</u>**<u>菱形继承问题</u>**<u>”，即当多个基类继承自同一个祖先类时，派生类最终可能会包含多个相同的基类实例（内存开销，二义性）。</u>解决方法是使用虚拟继承

<u>在虚拟继承中，基类只会有一个实例，派生类共享这个实例。</u>

<u>在构造D对象时，构造函数的调用顺序:</u>

<u>虚基类：调用最底层的虚基类构造函数(A)。</u>

<u>非虚基类：按照它们在派生列表中的顺序调用非虚基类的构造函数。在这个例子中，B和C是非虚基类。</u>

<u>派生类：最后调用派生类D的构造函数。</u>

<h4 id="872ad320">**继承模型**</h4>
_**<u>简单的继承模型（使用的是这个）：</u>**_

<u>在C++最初的继承模型中，基类的成员直接被放置在派生类对象中。这意味着派生类可以直接访问基类的数据成员，不需要任何间接性。这种方式的好处是访问效率高，因为没有额外的指针或查找过程。</u>

<u>直接将基类成员嵌入到派生类对象中，使得内存布局紧凑，并且对基类成员的访问非常快。编译器可以很容易地生成这样的代码，它不涉及复杂的间接寻址。</u>

<u>如果基类有任何变化（如添加、删除或修改成员），所有使用该基类或其派生类的对象都需要重新编译。这是因为基类的变化会直接影响派生类对象的内存布局。</u>

_**<u>指针复制的方法(未使用):</u>**_

<u>在每个派生类中复制一个指向每一个相关基类的指针，这可以提供恒定时间的访问，但需要额外的内存来存放这些指针。固定访问时间：无论继承层次多深，访问基类成员的时间都是固定的。</u>

<u>额外空间开销：每个派生类对象需要额外的空间来存放指向基类的指针。</u>

**<u>虚继承：</u>**

虚继承的内存模型

💡

[虚继承合成的构造函数](https://kdocs.cn/l/cuSTtRAG1IvG?linkname=YjSGqqBlkO)

<h4 id="6ad6da6b">关键词所带来的差异</h4>
与C语言的兼容性(函数指针为例):

C++被设计为对C语言的一种扩展，C++必须能够编译大部分有效的C代码。由于C++保留了C的声明语法，有时会导致编译器难以区分某些语句是函数声明还是函数调用。这需要编译器进行“向前预览”来解决歧义，增加了语言解析的复杂度。

在C++中，一个典型的例子是函数指针的声明与函数调用之间的歧义。考虑以下C++语句：

```cpp
int(*pf)(1024);
```

这个语句既可以解释为一个函数指针pf的声明，也可以解释为一个名为pf的函数调用。

函数指针声明：int(*pf)(1024); 声明了一个指向函数的指针pf，该函数接受一个整数参数并返回一个整数。

函数调用：如果pf已经被定义为一个函数，那么int(*pf)(1024); 可能会被误解为对pf函数的调用，并且将结果赋值给一个整型变量。

编译器如何解决歧义

为了解决这种歧义，编译器需要进行“向前预览”（lookahead），即提前查看更多的上下文信息来确定正确的解析方式。在这个例子中，编译器会检查1024是否是一个有效的函数调用参数。如果1024是一个常量或表达式而不是标识符，那么它更可能是一个函数指针的声明，因为函数调用通常不会直接使用数字作为参数名。编译器必须执行更多的工作来解析这些复杂的声明，这可能会导致编译时间的增加。

代码可读性降低：对于人类程序员来说，这样的声明也可能难以阅读和理解，增加了维护代码的难度。

（这个问题没有搞懂）

为了避免这种歧义，C++11引入了新的语法，允许使用auto关键字和类型推导来简化函数指针的声明。

```cpp
auto pf = [](int x) -> int { return x; };  // 使用lambda表达式初始化函数指针
```

或者使用std::function：

```cpp
#include <functional>
std::function<int(int)> pf = [](int x) { return x; };
```

这减少了编写和解析复杂声明时的错误。虽然C++保留了C的语法以保持兼容性，但这确实带来了一些额外复杂，现代C++通过引入新的特性和语法试图减轻这些问题。

**struct和class的使用**

<u>在C++中，struct和class关键字几乎可以互换使用，但它们的历史背景不同。struct源自C语言，主要用于定义数据结构；class则是C++引入的，用于实现面向对象编程中的封装、继承等特性。尽管如此，在实际使用中，两者都可以用来定义具有相同特性的用户自定义类型。</u>

<u>struct和class的实际区别：从语言的角度来看，struct默认成员访问级别为public，而class则默认为private。但是，这个默认行为可以通过显式指定访问控制符来改变，因此两者的功能上并没有本质的区别。</u>

<u>模板参数列表中的关键字：在早期的C++版本中，模板参数列表里只能使用class关键字，而不能使用struct。后来这个问题得到了修正，使得两种关键字都能被接受。</u>

<u>虽然从技术角度讲，C++只需要保留struct或引入新的class关键字之一即可，但实际上保留struct是为了方便C程序员过渡到C++，同时引入class则是为了表达C++特有的面向对象编程理念。</u>

（标准答案：看个人喜好）

<h4 id="a99a5b8b">策略性正确的 struct</h4>
📌

**关联知识点：**

GNC 可变数组(struct) [https://kdocs.cn/l/cdJckFJoCYgL?linkname=b7rMHddAAN](https://kdocs.cn/l/cdJckFJoCYgL?linkname=b7rMHddAAN)

在C语言中，有时会使用一种技巧来创建可变大小的结构体。

```cpp
struct mumble {
/* stuff */
char pc[1];
};

//从文件或标准输入装置中取得一个字符串.
//然后为struct本身和该字符串配置足够的内存.
struct mumble *pmumble = (struct mumble*)malloc(sizeof(struct mumble) + strlen(string) + 1);
strcpy(pmumble->pc, string);
```

这里char pc[1]实际上是一个占位符，用于动态分配额外的内存。通过这种方式，可以分配足够的内存来存储一个字符串。

这种方法依赖于结构体成员在内存中的布局是连续的，并且可以扩展最后一个成员的大小。

**<u>在C++中，如果将上述技巧应用于类，可能会遇到以下问题：</u>**

**<u>访问控制：C++类可以有多个访问控制部分（public, protected, private），这些部分的数据成员在内存中的排列顺序是不确定的。</u>**

```cpp
class stumble {
public:
// operations ...
protected:
// protected stuff
private:
/* private stuff */
char pc[1];
};
```

**<u>char pc[1]的位置可能因为不同的编译器优化而变化，导致无法保证与C语言中相同的内存布局。如果类是从其他类派生的，基类和派生类的数据成员的布局也是不确定的。这会影响内存布局的一致性。如果类中有虚函数，编译器会在每个对象中插入一个指向虚函数表的指针（vtable pointer），这也会影响内存布局。</u>**

<h4 id="bcfd2558">对象的差异</h4>
C++程序设计模型支持的三种编程范式

**过程式编程范式 ：**

类似于C语言，使用函数和全局变量。

```cpp
char boy[] = "Danny";
char *p_son;
p_son = new char[strlen(boy) + 1];
strcpy(p_son, boy);
if (!strcmp(p_son, boy)) {
    take_to_disneyland(boy);
}
```

**抽象数据类型模型 (ADT)**

提供一组公开接口，内部实现细节隐藏。

```cpp
String girl = "Anna";
String daughter = girl;
if (girl == daughter) {
    take_to_disneyland(girl);
}
```

**面向对象编程范式 **

通过继承和多态来封装和扩展功能。

```cpp
class Library_materials {
public:
virtual bool late() const = 0;
virtual void fine() = 0;
virtual void check_in() = 0;
virtual Lender* reserved() const = 0;
virtual void notify(Lender* plend) = 0;
};
class Book : public Library_materials {
public:
// 实现基类的纯虚函数
};
void check_in(Library_materials* pmat) {
    if (pmat->late()) {
        pmat->fine();
    }
    pmat->check_in();
    if (Lender* plend = pmat->reserved()) {
        pmat->notify(plend);
    }
}
```

**多态和切片问题**

<u>多态通过基类指针或引用调用派生类的方法。通过虚函数机制在运行时动态绑定具体的方法。</u>

<u>切片问题</u>

<u>将派生类对象赋值给基类对象时，派生类特有的部分会被“切掉”。</u>

```cpp
Library_materials thing1;
Book book;
thing1 = book;  // 切片问题
thing1.check_in();  // 调用的是 Library_materials::check_in()
```

<u>解决方案：使用基类指针或引用。</u>

```cpp
Library_materials& thing2 = book;
thing2.check_in();  // 调用的是 Book::check_in()
```

<h4 id="248fd06a">指针cast的理解</h4>
📌

关联知识点：指针

<u>32位机器上指针都是32位，从内存角度来看，并没有什么区别。</u>

<u>跟编译器如何解释指针指向内存内容有关。</u><u>转换(cast)其实是一种编译器指令。大部分情况下它并不改变一个指针所含的真正地址，只影响“被指出之内存的大小和其内容"。</u>

<h1 id="552dc8e6">构造函数语意学</h1>
**<font style="color:#db7800;">什么是隐式类型转换,有什么问题,如何解决？</font>**

**<font style="color:#db7800;">什么情况下会生成默认构造函数,它的操作是什么？</font>**

**<font style="color:#db7800;">派生类的默认构造函数什么时候会生成(不派生也没有虚函数的类,派生的类,有虚函数的类,有虚继承的类)?</font>****<font style="color:#d1a300;">哪3种情况会调用拷贝构造函数？</font>****<font style="color:#db7800;">什么时候会生成一个默认的拷贝构造函数？什么是bitwise copy?对象按值传递和按引用传递有什么不同？什么是返回值优化？</font>**

![](https://cdn.nlark.com/yuque/0/2025/png/45533403/1742810993619-e8ecad4e-b53c-4277-9dd2-82cb058a084a.png)

<h4 id="49437975">**C++中隐式类型转换的问题**</h4>
在C++中，可以为类定义一个类型转换运算符，允许对象被隐式地转换成另一个类型，如operator int()可以让一个类的对象当作整数使用。

但是这种隐式类型转换有时会导致意外。如为了让cin可以用于条件判断（如if (cin) ...），定义了一个operator int()，这样cin就可以被转换成一个整数值。如果不小心写错了代码，比如本该是cout << intVal；误写成了cin << intVal;，那么编译器会尝试将cin转换为整数，并且由于存在operator int()，这个转换是合法的。编译器会将这个转换后的整数值与intVal进行位移操作（即<<运算符），这显然不是程序员所期望的行为。

<u>引入explicit关键字是为了进一步控制构造函数和转换运算符的行为。当一个构造函数被声明为explicit时，它就不能用于隐式转换；同样，explicit也可以应用于转换运算符，以防止它们被用于隐式转换。</u>

<h4 id="73a05f7c">编译器合成默认构造函数的情况</h4>
<u>在C++中，当一个类没有用户定义的构造函数时，编译器会在某些情况下自动提供一个默认构造函数(default constructor)。默认构造函数被称为隐式声明的默认构造函数。</u>根据C++标准，这种隐式的默认构造函数的行为是有限制的，它不会对成员变量进行初始化，除非这些成员自身有默认构造函数，并且它们会按照自己的规则被初始化。如果只是依赖于编译器合成的默认构造函数，那么 val 和 pnext 实际上不会被显式地初始化为0。

<h5 id="8ed18cdb">带有 Default Constructor 的 Member Class Object</h5>
<u>在C++中，当一个类（例如 Bar）没有显式定义构造函数，但包含了一个或多个成员对象，并且这些成员对象有默认构造函数时，编译器会为该类合成一个默认构造函数。这个合成的默认构造函数是“非平凡”（nontrivial）的，因为它需要调用成员对象的默认构造函数来确保它们被正确初始化。</u>

如果 Bar 类没有任何构造函数，但是它有一个成员对象 Foo foo;，而 Foo 类有默认构造函数，那么编译器会为 Bar 合成一个默认构造函数。这个默认构造函数负责调用 Foo 的默认构造函数来初始化 foo，<u>但不会对其他成员如 char* str; 进行初始化。</u>

<u>如果程序员希望 str 也被初始化，他们需要提供一个显式的默认构造函数来处理这种情况。</u>

```cpp
class Dopey {
public:
Dopey() { /* ... */ }
};
class Sneezy {
public:
Sneezy(int) { /* ... */ }
Sneezy() { /* ... */ }
};
class Bashful {
public:
Bashful() { /* ... */ }
};
class Snow_White {
public:
Dopey dopey;
Sneezy sneezy;
Bashful bashful;
int mumble;
Snow_White() : sneezy(1024) {
    mumble = 2048;
}
};
```

如果 Snow_White 没有定义默认构造函数，编译器会合成一个默认构造函数，按成员声明顺序调用 Dopey、Sneezy 和 Bashful 的默认构造函数。如果程序员提供了上面那样的默认构造函数，编译器会扩展它，确保所有成员对象都被正确初始化：

```cpp
// 扩展后的 Snow_White 默认构造函数
Snow_White::Snow_White() : dopey(Dopey()), sneezy(Sneezy(1024)), bashful(Bashful()) {
    mumble = 2048;
}
```

dopey 通过其默认构造函数初始化，sneezy 通过带参数的构造函数初始化，bashful 通过其默认构造函数初始化。最后执行用户提供的初始化代码 mumble = 2048。

<h5 id="218e8d95">_<u>派生类合成的构造函数：</u>_"带有 Default Constructor"的Base Class</h5>
<u>在C++中，当一个派生类(derived class)没有任何构造函数时，如果它的基类（base class）有一个默认构造函数，那么编译器会为这个派生类合成一个默认构造函数。这个合成的默认构造函数被视为“非平凡”（nontrivial），因为它需要调用基类的默认构造函数来确保基类部分被正确初始化。</u>

_**<u>情况1:派生类没有构造函数，基类有默认构造函数</u>**_

```cpp
class Base {
public:
Base() { /* 基类的默认构造函数 */ }
};
class Derived : public Base {
// 派生类没有任何构造函数
};
```

<u>在这种情况下，编译器会为 Derived 类合成一个默认构造函数，将调用 Base 的默认构造函数。</u>

```cpp
inline Derived::Derived():Base(){}
```

_**情况2：派生类提供了多个构造函数，但没有默认构造函数**_

<u>如果派生类提供了多个构造函数，但其中没有一个是默认构造函数，编译器不会合成一个新的默认构造函数。相反，它会扩展现有的每一个构造函数，在每个构造函数的初始化列表中插入必要的代码，以调用基类的默认构造函数和成员对象的默认构造函数(如果有)。</u>

```cpp
class Composite {
public:
A a;
B b;
C c;
Composite(){/*默认构造函数*/}
};
```

在 Composite 类的默认构造函数中，成员对象的初始化顺序是 a、b 和 c，这与它们在类中的声明顺序一致。

<h5 id="e61bd508">虚函数合成的构造函数："带有一个Virtual Function"的Class</h5>
虚函数表和虚函数表指针

在C++中，当一个类声明了至少一个虚函数时，编译器会为该类生成一个虚函数表（vtable），并且每个对象都会包含一个指向这个虚函数表的指针（vptr）。虚函数表和虚表指针的存在使得多态性得以实现，即通过基类指针或引用可以调用派生类的具体实现。

<h5 id="accc9717">虚函数表和虚表指针/重新设定 Virtual Table的指针</h5>
虚函数表(vtable)：每个包含虚函数的类都有一个与之关联的虚函数表。虚函数表是一个数组，存储了该类的所有虚函数的地址。虚函数表在编译时生成，并且**<u><font style="color:#c21c13;">对于每个类只有一个实例。</font></u>**

+ **<u>虚函数表的共享：</u>**<u>对于一个特定的类,所有该类的对象都会共享同一个虚函数表,这张表存储了该类及其基类的所有虚函数的地址。</u>
+ **<u>vptr的独立性</u>**<u>：虽然所有对象的 vptr 指向相同的虚函数表，但每个对象都有自己独立的 vptr。每个对象的 vptr 是其自身的一部分，指向类的虚函数表，确保在对象的生命周期内能够正确地调用相应的虚函数实现。</u>

<u>虚表指针 (vptr)：每个对象都包含一个指向其类的虚函数表的指针（vptr）。vptr 通常位于对象内存布局的最前面，这样可以通过基类指针快速访问到虚函数表。当通过基类指针调用虚函数时，编译器会使用对象的 vptr 找到相应的虚函数表，然后从表中获取实际的函数地址并调用。</u>

<u>在C++中当一个类包含虚函数 或 继承自一个含有虚基类的继承链时，即使该类没有显式定义任何构造函数，编译器也会为其合成一个默认构造函数。这个合成的默认构造函数是必要的，因为它需要初始化一些内部机制，如虚函数表指针（vptr）和虚基类子对象。</u>

<u>合成的默认构造函数可能看起来像这样:</u>

```cpp
inline Widget::Widget() {
    // 初始化 vptr
    vptr = &Widget::vtable;
}
```

假设我们有以下类结构：

在这个例子中，Widget 类有一个纯虚函数 flip()，因此 Widget 是一个抽象类。Bell 和 Whistle 类都派生自 Widget 并实现了 flip() 函数。

<u>编译器会为每个包含虚函数的类生成一个虚函数表（vtable)。虚函数表是一个静态数组，存储了该类的所有虚函数的地址。</u>对于 Widget 类，vtable 可能看起来像这样。

<u>每个包含虚函数的类的对象都会有一个额外的成员变量 vptr，它是一个指向对应类的 vtable 的指针。</u>

<u>在 Widget 类的对象中，vptr 会被初始化为 Widget 的 vtable 地址。</u>

<u>虚函数调用会被编译器重写为通过 vptr 来访问 vtable 中的函数地址。</u>

<h5 id="32e87a14"><u>虚继承合成的构造函数</u></h5>
<u>如果一个类继承自一个虚基类，编译器也需要合成一个默认构造函数来正确初始化虚基类部分。虚基类的初始化涉及到更复杂的机制，因为多个派生类可能会共享同一个虚基类实例。</u>

假设有以下类结构：

```cpp
class Base {
public:
int value;
Base() : value(0) {}
};
class Derived1 : virtual public Base {
// 派生类1
};
class Derived2 : virtual public Base {
// 派生类2
};
class Final : public Derived1, public Derived2 {
// 最终派生类
};
```

在这种情况下，Derived1 和 Derived2 都继承自 Base，并且 Base 是虚基类。Final 类从 Derived1 和 Derived2 派生。编<u>译器会为 Derived1 和 Derived2 合成默认构造函数，以确保 Base 部分被正确初始化。</u>

合成的默认构造函数可能看起来像这样：

```cpp
inline Derived1::Derived1() : Base() {
    // 初始化 vptr
    vptr = &Derived1::vtable;
}
inline Derived2::Derived2() : Base() {
    // 初始化 vptr
    vptr = &Derived2::vtable;
}
```

对于 Final 类，编译器会扩展其构造函数，确保所有基类和虚基类都被正确初始化：

```cpp
inline Final::Final() : Base(), Derived1(), Derived2() {
    // 初始化 vptr
    vptr = &Final::vtable;
}
```

<u>在C++中，虚基类的实现机制在不同的编译器之间可能有所不同，但它们都有一个共同的目标：确保虚基类在每个派生类对象中的位置能够在运行时被正确访问。</u>

**虚基类的位置问题**

<u>当一个类继承自虚基类时，虚基类在派生类对象中的具体位置不能在编译时确定。这是因为虚基类可能通过多条继承路径被共享，而每条路径可能导致不同的偏移量。</u>

<u>X 是 A 和 B 的虚基类，而 C 继承自 A 和 B。由于 X 是虚基类，X::i 在 A 和 C 对象中的位置是不确定的。为了在运行时能够正确访问虚基类成员，编译器会采取一些特定的机制。早期的cfront编译器采用的方法是在每个派生类对象中为每个虚基类插入一个指针。这个指针指向虚基类的实际位置，从而使得虚基类成员的访问可以在运行时动态决定。</u>

理解：虚基类的核心特性是**共享。**无论虚基类在继承层次中出现多少次，派生类对象中只会存在一个虚基类的实例。这种共享性是为了避免多重继承中的“菱形继承”问题（即同一个基类在继承层次中被多次继承，导致数据冗余和二义性)。

多条继承路径导致偏移量不确定：在多重继承中,虚基类的位置依赖于具体的继承路径。不同的继承路径可能导致虚基类在派生类对象中的偏移量不同。在`A`中，`X`的偏移量可能是某个值;在`B`中,`X`的偏移量可能是另一个值；在`C`中，`X`的偏移量需要综合考虑`A`和`B`的布局。

**<u>便于虚继承的理解：</u>**

在C++中，类继承的内存布局是派生类直接包含基类对象，而不是通过指针指向基类。

当派生类继承基类时，基类的成员变量会直接嵌入到派生类的内存布局中。派生类的对象在内存中会包含基类的所有成员变量，以及派生类自己定义的成员变量。这种布局是连续的，派生类对象的内存块中首先存储基类的成员变量，然后才是派生类的成员变量。所以如果出现菱形继承，可能有派生类中会有两个基类的拷贝，会造成数据冗余，还有调用的二义性。

![](https://cdn.nlark.com/yuque/0/2025/png/45533403/1742810993665-ec85f7b3-0cda-4d9c-92cf-fbb1eb782491.png)

[https://www.cnblogs.com/budapeng/p/3305790.html](https://www.cnblogs.com/budapeng/p/3305790.html)

虚基类表原理与虚函数表类似，不过虚基类表的内容有所不同。表的第一项表示派生类对象指针相对于虚基类表指针的偏移，从第二项开始表示各个基类地址相对于虚基类表指针的偏移。

![](https://cdn.nlark.com/yuque/0/2025/png/45533403/1742810994112-10340985-df89-471b-a0cf-8250e25eb767.png)

为了支持虚基类的共享性和唯一性，编译器需要在运行时动态确定虚基类的位置。编译器会为每个派生类生成一个**虚基类表，**其中存储了虚基类的偏移量。当访问虚基类的成员时，编译器会通过虚基类表查找虚基类的实际位置。在`C`对象中：`A`和`B`可能各自存储了一个指向 `X` 的指针(或偏移量)。当访问 `X::i`时,编译器会根据当前对象的类型(`A,B`或`C`)动态计算出 `X` 的位置。

**<u>优点:</u>**

（1）单一实例：保证了一个公共基类在派生类层次中只有一个实例，这对于某些设计模式（如组合/聚合）是非常有用的。

（2）减少冗余：避免了由于多次继承而导致的数据冗余。

<u>缺点：</u>

1. 增加了间接性：访问虚基类的成员需要通过指针间接完成，这可能会导致性能下降。

<u>(2) 复杂性增加：编译器需要处理更多的细节来维护虚基类的位置，这可能会使内存布局和运行时行为更加复杂。</u>

<u>(3) 额外空间开销：为了跟踪虚基类的位置，每个派生类对象可能需要额外的空间来存储指针。</u>

<h5 id="94b1c041">**<u>总结：构造函数的作用</u>**</h5>
为了确保这些指针在运行时能够正确设置，编译器需要在构造函数中插入相应的代码。对于每个用户定义的构造函数，编译器会添加必要的代码来初始化这些指针。如果类没有显式定义任何构造函数，编译器会为其合成一个默认构造函数，以确保这些指针被正确初始化。

有上面几种情况，编译器必须为未声明 constructor 的classes 合成一个 default constructor。

误解：1.任何 class 如果没有定义 default constructor,就会被合成出一个来。2.编译器合成出来的 default constructor会显式设定"class 内每一个 data member的默认值"。

<h4 id="da79b275">拷贝构造函数的构造操作</h4>
拷贝构造函数用于使用同一类的一个对象来初始化新创建的对象。当需要一个对象作为另一个对象的副本时，拷贝构造函数就会被调用。有三种情况会触发拷贝构造函数的调用。

**<u>（1）显式初始化</u>**

<u>显式地使用已存在的对象来初始化一个新的对象时(赋值运算符)</u>

```cpp
X x;  // 假设 x 已经存在
X xx = x;  // 这里会调用 X 的拷贝构造函数来创建 xx
```

**<u>（2）以值传递参数</u>**

<u>当一个对象作为参数传递给一个函数，并且该函数是以值方式接受这个参数时。</u>

```cpp
void foo(X x) { /*...*/ }
X xx;  // 假设 xx 已经存在
foo(xx);  // 这里会调用 X 的拷贝构造函数来创建 x 参数的一个副本
```

<u>当 foo 函数被调用时，xx 的内容将被用来创建 x 参数的一个副本，拷贝构造函数同样会被调用。</u>

**<u>（3）返回对象</u>**

<u>当一个函数返回一个对象时，如果这个对象是通过 return 语句直接从局部变量或者临时对象返回，那么拷贝构造函数也会被调用。</u>

```cpp
X foo_bar() {
    X xx;  // 创建局部对象 xx
    //... 对 xx 进行操作
    return xx;  // 返回时可能调用拷贝构造函数
}
```

<u>当 foo_bar 返回 xx 时，通常情况下会创建 xx 的一个副本并将其作为返回值。不过，现代编译器可能会优化这种情况，使用一种称为“返回值优化”来避免额外的拷贝。</u>

<u>如果类定义了一个用户自定义的拷贝构造函数</u>

```cpp
X::X(const X& x);
```

<u>那么上述任何一种情况下，都会调用这个自定义的拷贝构造函数来完成对象的复制。如果没有提供自定义的拷贝构造函数，编译器会生成一个默认的拷贝构造函数，它执行的是浅拷贝，即逐个成员进行比特级的复制。</u>**<u>对于含有指针或动态分配资源的类来说，这可能导致问题，如多次删除同一个内存区域等，因此在这种情况下定义自己的拷贝构造函数是很重要的。</u>**

<h5 id="5ccd9265">合成的拷贝构造函数</h5>
<u>当一个类没有提供显式的拷贝构造函数时，C++编译器会为该类自动生成一个默认的拷贝构造函数。这个默认的拷贝构造函数执行的是所谓的"成员逐个初始化"，它会按照每个数据成员的顺序依次进行浅拷贝。</u>

<u>对于简单的类型，比如整数、指针等，这种浅拷贝是直接将源对象的数据成员的值复制到目标对象的数据成员中。对于复杂的类型，比如另一个类的对象，编译器会递归地调用那个类的拷贝构造函数来完成复制。 指针的浅拷贝会导致 拷贝和被拷贝的对象指向同一块内存，可能导致资源管理问题，比如在析构时两次释放同一个内存区域。因此，对于包含动态分配资源的类，通常需要自定义拷贝构造函数以实现深拷贝。</u>

<h5 id="38b99496">位逐次拷贝</h5>
<u>位逐字拷贝（bitwise copy）是指直接复制对象在内存中的二进制表示，而不需要调用拷贝构造函数。这种方式适用于那些没有动态分配资源、没有虚函数、没有自定义析构函数或拷贝赋值运算符的类。</u>

<u>（1）所有非静态数据成员都是平凡类型：这些成员本身也支持位逐字拷贝。</u>

<u>（2）类没有虚函数：因为虚函数的存在意味着有虚表指针，这需要特别处理。</u>

<u>（3）类没有用户定义析构函数：用户定义的析构函数通常意味着类管理着某些资源，简单的内存拷贝可能会导致资源管理问题。</u>

<u>（4）类没有用户定义拷贝赋值运算符：用户定义的拷贝赋值运算符通常意味着类需要特殊的复制逻辑。</u>

<h4 id="0aa7866d">理解对象如何初始化以及拷贝构造函数的调用</h4>
<h5 id="f0cfc0f1">**<u>显式初始化操作</u>**</h5>
在 `foo_bar()` 函数中，通过显式的定义，程序中对 `x1`, `x2`, 和 `x3` 的初始化操作被替换为拷贝构造函数的调用。

```cpp
// 假设有这样的定义
X x0; // 定义一个全局对象 x0
void foo_bar() {
    // 原始初始化操作
    X x1(x0); // 使用 x0 初始化 x1
    X x2 = x0; // 使用 x0 初始化 x2
    X x3(X(x0)); // 使用 x0 初始化 x3
}
====>>
    void foo_bar() {
    // 重写的定义，剥除初始化操作
    X x1; // 定义 x1，初始化操作被剥除
    X x2; // 定义 x2，初始化操作被剥除
    X x3; // 定义 x3，初始化操作被剥除
    // 编译器安插 X 的拷贝构造函数的调用操作
    x1.X::X(x0); // 显式调用拷贝构造函数 X::X(const X& xx)
    x2.X::X(x0); // 显式调用拷贝构造函数 X::X(const X& xx)
    x3.X::X(x0); // 显式调用拷贝构造函数 X::X(const X& xx)
}
```

<h5 id="32df59dc">对象的按值传递和按引用传递</h5>
💡

关联知识点：

函数传参(C和指针)，

```cpp
#include <iostream>
using namespace std;
class X {
public:
X() {
    cout << "Constructor called!" << endl;
}
X(const X& other) {
    cout << "Copy Constructor called!" << endl;
}
~X() {
    cout << "Destructor called!" << endl;
}
};
// 按值传递
void foo_by_value(X x0) {
    cout << "Inside foo_by_value" << endl;
}
// 按引用传递
void foo_by_reference(X& x0) {
    cout << "Inside foo_by_reference" << endl;
}
int main() {
    X xx; // 创建一个对象 xx
    cout << "Calling foo_by_value:" << endl;
    foo_by_value(xx); // 按值传递
    cout << "Calling foo_by_reference:" << endl;
    foo_by_reference(xx); // 按引用传递
    return 0;
}
Constructor called!          // 创建对象 xx
    Calling foo_by_value:
Copy Constructor called!     // 生成临时对象，调用拷贝构造函数
    Inside foo_by_value
Destructor called!           // 临时对象销毁，调用析构函数


Calling foo_by_reference:
Inside foo_by_reference      // 没有临时对象生成
    Destructor called!           // 对象 xx 销毁
```

**按值传递**`**(foo_by_value)**`

当调用 `foo_by_value(xx)`时,编译器会生成一个临时对象,并将`xx`的值拷贝到这个临时对象中(调用拷贝构造函数)。临时对象在函数 `foo_by_value` 结束后会被销毁，调用析构函数。如果类 `X` 中有动态分配的资源(如指针)，位拷贝会导致浅拷贝问题，临时对象和原对象可能会共享同一块内存，导致重复释放或内存泄漏。当调用 `foo_by_reference(xx)` 时，`x0` 直接引用 `xx`，不会生成临时对象，也不会调用拷贝构造函数。没有额外的临时对象生成和销毁，避免了资源管理问题。如果函数不需要修改传入的对象，可以使用 `const` 引用，如 `void foo_by_reference(const X& x0)`。

**返回值优化**

💡

**关联知识点：**

函数调用和栈帧(_<u>结合函数调用来看)</u>_

阅读材料：[https://blog.csdn.net/u011386173/article/details/121084722?ops_request_misc=%257B%2522request%255Fid%2522%253A%252208EA1958-3538-4FFF-9229-CD2C0E8D728A%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=08EA1958-3538-4FFF-9229-CD2C0E8D728A&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-121084722-null-null.142^v100^pc_search_result_base9&utm_term=%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BC%98%E5%8C%96&spm=1018.2226.3001.4187](https://blog.csdn.net/u011386173/article/details/121084722?ops_request_misc=%257B%2522request%255Fid%2522%253A%252208EA1958-3538-4FFF-9229-CD2C0E8D728A%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=08EA1958-3538-4FFF-9229-CD2C0E8D728A&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-121084722-null-null.142^v100^pc_search_result_base9&utm_term=%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BC%98%E5%8C%96&spm=1018.2226.3001.4187)

<u>在C++中，当一个函数返回一个局部对象时，通常会调用拷贝构造函数来创建返回值的副本。</u>

<u>这种行为可能会导致不必要的性能开销，因为对象的创建和销毁都需要一定的资源。为了避免这个开销，编译器通常会采用返回值优化（RVO），在某些情况下直接在调用者的内存空间中构造对象，而不是通过拷贝构造。</u>

<u>在没有优化的情况下，返回值的处理过程可以表示如下：</u>

1. **<u>函数定义：</u>**`<u>bar()</u>`<u>返回一个局部对象</u>`<u>xx</u>`<u>。</u>
2. **<u>调用时：</u>**`<u>X xx = bar();</u>`<u> 会引发一个拷贝构造的调用。</u>

双阶段转化解决方案

为了优化这一过程,Stroustrup 的 `cfront` 实现提出了一个双阶段转化的解决方案。编译器会将函数的返回值处理直接转移到调用者的对象上，从而避免额外的拷贝构造开销。假设有一个类 `X`，函数 `bar()`如下所示

```cpp
#include <iostream>
using namespace std;
class X {
public:
X(){ cout << "Constructor called!" << endl; }
X(const X& other) { cout << "Copy Constructor called!" << endl;}
~X(){ cout << "Destructor called!" << endl; }
};
// 原始函数：返回局部对象
X bar() {
    X xx; // 创建局部对象
    return xx; // 返回局部对象
}
// 双阶段转化后的函数
void bar(X& _result) {
    X xx; // 创建局部对象
    _result = xx; // 将 xx 的内容拷贝到 _result
    return; // 不返回值
}
int main() {
    cout << "Calling original bar():" << endl;
    X xx1 = bar(); // 调用原始函数
    cout << "\nCalling transformed bar():" << endl;
    X xx2;
    bar(xx2); // 调用双阶段转化后的函数
    return 0;
}
```

**避免不必要的拷贝构造**：通过将返回值的处理直接转移到调用者的对象上，避免了额外的拷贝构造。

**对调用的透明性**：程序员可以继续使用传统的函数调用方式，而不必担心性能开销。

**灵活性**：这种方式在函数指针和临时对象的情况下也能保持有效。

（在调用者的栈帧开辟一段内存空间，然后调用的函数的时候，在函数中直接把生成的对象拷贝到调用者的栈帧的内存空间中；否则需要在被调用者的栈帧中生成临时对象，然后把临时对象拷贝到调用者的栈帧中）

<h5 id="13d86ea5">手动实现Copy Constructor</h5>
💡

关联知识点：

memset和memcopy [https://kdocs.cn/l/cdG2hX3TcAWz?linkname=bQaTjiefdq](https://kdocs.cn/l/cdG2hX3TcAWz?linkname=bQaTjiefdq)

1. **默认拷贝构造函数**：

C++提供了默认的拷贝构造函数，它执行逐位复制(bitwise copy)，在大多数情况下是高效且安全的,对于简单的数据类型如数值类型。对于`Point3d`类，三个坐标成员都是简单的数值类型，因此默认的拷贝构造函数工作得很好，没有内存泄漏的问题。由于默认的拷贝构造函数表现良好，因此在这个特定情况下，设计者不需要显式定义一个拷贝构造函数。<u>如果将来需要大量的按值传递操作（例如在运算符重载中），则可以考虑提供一个显式的拷贝构造函数来提高代码的可读性和可维护性。</u>

**拷贝构造函数的实现**

最简单的拷贝构造函数

```cpp
Point3d::Point3d(const Point3d& rhs) {
    _x = rhs._x;
    _y = rhs._y;
    _z = rhs._z;
}
```

另一种实现方式是使用`memcpy`，这在数据结构中只包含简单类型时可以更高效：

```cpp
Point3d::Point3d(const Point3d& rhs) {
    memcpy(this, &rhs, sizeof(Point3d));
}
```

使用 `memcpy` 和 `memset` 的注意事项

使用`memcpy`或`memset`时需要小心，当类中包含虚函数或虚基类时。会影响到类的内部结构，尤其是虚指针（vptr）的初始化。在包含虚函数的类中，编译器会生成额外的内部成员（如虚指针），这些成员在使用`memcpy`或`memset`时会被错误地覆盖(带有虚基类和虚函数的类不能使用memset和memcpy).

在下面的`Shape`类中，如果使用`memset`来初始化对象，会导致`vptr`被设置为零，破坏对象的虚函数机制：

```cpp
class Shape {
public:
virtual ~Shape();
// ...
};

Shape::Shape() {
    // vptr 必须在使用者的代码执行之前先设定妥当
    __vptr_Shape = _vtbl_Shape;
    memset(this, 0, sizeof(Shape));  // 错误：将 vptr 清为 0
}
```

<h4 id="fd4f0df5">成员初始化列表（没看）</h4>
<u>成员初始化列表允许在对象创建时直接初始化类成员，而不是先调用默认构造函数创建成员对象，然后再通过赋值操作更新其值。</u>

只能使用初始化列表的情况

**（1）引用类型成员:**引用必须在创建时进行初始化，且无法更改，因此必须用初始化列表。

**（2）常量成员：**const成员在构造后不可更改，所以只能通过初始化列表进行初始化。

**（3）有参数的基类构造函数:**如果基类的构造函数需要参数，必须在初始化列表中传入，C++ 不会自动调用有参数的基类构造函数。

**（4）有参数的成员类构造函数: **若类中的某个成员自身有构造函数并且需要参数，那么也需要在初始化列表中传入参数。

_**为什么成员初始化列表效率更高？**_

<u>当不使用成员初始化列表时，类的成员变量会先使用默认构造函数被初始化一次，然后通过赋值运算符再赋值一次，导致不必要的开销。</u>

```cpp
class Word {
String _name;
int _cnt;
public:
Word() {
    _name = "default";  // 先默认构造，然后赋值
    _cnt = 0;
}
};
```

`_name` 会先通过 `String` 的默认构造函数初始化，再通过赋值操作重新赋值。这种重复操作在需要频繁构造对象的场景下，可能导致不必要的性能浪费。优化后用成员初始化列表来初始化 

```cpp
Word::Word() : _name("default"), _cnt(0) {}
```

`<u>_name</u>`<u> 会在对象创建时直接使用带参构造函数初始化，不会有临时对象生成和赋值操作更高效。</u>

<u>当定义一个类的成员变量时，编译器会在构造该类的对象时自动调用该成员变量的构造函数来初始化它。这是因为类成员是对象的组成部分，必须被正确初始化以确保对象处于有效状态。</u>

<u>在成员初始化列表中，编译器会按照成员在类中声明的顺序依次调用构造函数进行初始化，而不是按照初始化列表中变量的顺序。</u>_<u>成员的初始化顺序取决于声明顺序，因此写初始化列表时最好与声明顺序一致，以避免潜在问题。</u>_

在模板代码中，类型`type`不确定时可能会引发错误。

```cpp
template<classType>
Foo<Type>::Foo(Type t) : _member(t) {
    --t;
}
```

`Type` 的实际类型可能没有定义 `--` 操作符，这行代码可能导致编译错误。解决方案是确保在成员初始化列表中完成对成员的初始化，避免对 `Type` 的操作造成意料之外的行为。可以只在初始化列表中对 `_member` 进行初始化，不要在构造函数主体中对`t`进行递减操作。

```cpp
template <classType>
Foo<Type>::Foo(Type t) : _member(t) {
    // 不进行 --t 操作，避免类型不支持时导致编译错误
}
```

有些新手会误以为成员初始化列表是一组函数调用，但实际上，它只是告诉编译器在对象创建时用哪个构造函数来初始化每个成员。

显式初始化列表 vs. 构造函数内联扩展

```cpp
class Point {
public:
Point(float x=0,float y=0,float z=0): _x(x),_y(y), _z(z){}//显式初始化列表
Point() {
    _x = 0.0;
    _y = 0.0;
    _z = 0.0;
} // 构造函数内联扩展
private:
float _x, _y, _z;
};
void mumble() {
    Point locall(1.0, 1.0, 1.0);  // 使用显式初始化列表
    Point local2;  // 使用构造函数内联扩展
}
```

<u>使用显式初始化列表（如Point locall(1.0, 1.0, 1.0);）通常比通过构造函数内联扩展（如Point local2;后手动设置成员变量）更高效，因为初始化值可以直接写入对象的内存中，避免了额外的赋值操作。</u>由于需要手动编写，如果忘记初始化某个成员变量，或者初始化顺序错误，可能会导致未定义行为或错误。

<h5 id="542d13d6">**<u>初始化列表调用成员函数可能存在的问题(了解)</u>**</h5>
**<u>在初始化列表中使用的成员函数调用时，某些成员变量可能尚未完成初始化</u>**<u>，从而导致未定义行为。</u>

初始化列表中成员变量的初始化顺序是由类中成员声明的顺序决定的，而不是初始化列表中书写的顺序。这意味着，即使在初始化列表中指定了成员变量的顺序，也会按照类的声明顺序初始化。

例如 在初始化列表中调用了一个成员函数 `foo`，而该函数依赖于另一个成员变量 `y` 的初值。

```cpp
class MyClass {
int x;
int y;
public:
MyClass(int val) : x(foo(val)), y(val) {}  
// 注意：foo()依赖于y 
int foo(int val){ return val + y; }       // 假设foo使用了成员y
};
```

`foo(val)` 试图使用成员变量 `y`，然而 `y` 的初始化尚未发生，因为 `x` 的初始化在 `y` 之前。由于 `y` 还未被赋值，`foo(val)` 的行为将是未定义的，这会导致不可预期的错误。

为了避免这种风险，建议在构造函数主体中执行依赖于其他成员变量的初始化逻辑：

在初始化列表中按顺序直接初始化成员变量，不调用依赖其他成员的函数。

在构造函数主体中调用需要其他成员变量的函数。

```cpp
class MyClass {
int x;
int y;
public:
MyClass(int val) : y(val) {   // 先初始化 y
    x = foo(val);             // 在构造函数体中调用 foo
}
intfoo(int val){ return val + y; }
};
```

这种方式确保了 `y` 在 `foo(val)` 调用之前已经被初始化，从而避免了未定义行为。

<h5 id="08c6a636">**<u>调用派生类成员函数作为基类构造函数的参数可能存在的问题（了解）</u>**</h5>
在派生类构造函数中，如果使用派生类的成员函数结果来初始化基类的构造函数参数，可能会导致问题。

```cpp
class X {
public:
X(int x){ /* ... */ }
};
class FooBar : public X{
int _fval;
public:
FooBar(int val) : _fval(val), X(fval()) {}
int fval(){ return _fval; }
};
```

`X(fval())`试图使用 `FooBar` 的成员函数 `fval()` 的返回值作为基类 `X` 的构造函数参数。

由于 `_fval` 的初始化发生在 `X` 之前，`fval()` 可能会使用尚未被初始化的 `_fval`，导致不可预期的行为。

**基类总是优先于派生类成员进行初始化**。在派生类中，成员的初始化顺序是按成员声明顺序进行，而非初始化列表中的顺序。

在`FooBar`的构造函数中,初始化顺序是

**（1）先初始化基类 **`**X**`（即`X(fval())`会先被调用）。

（2）然后按照声明顺序初始化派生类的成员 `_fval`。

由于`X`构造函数调用了 `fval()`，而 `_fval` 尚未初始化，调用 `fval()` 时 `_fval` 的值是未定义的，可能会导致不可预期的行为。

解决方案：

为了避免此类错误，可以将基类的初始化逻辑放到构造函数的主体中，确保 `_fval` 被正确初始化后再调用 `fval()`：

```cpp
FooBar(int val):_fval(val),X(0){  
    // 初始化为默认值
    this->X::X(fval());  // 这里可以手动调用 X 的构造函数
}
```

通过这种方式，可以避免派生类成员未初始化的问题。

<h1 id="9f895799">Data 语义学</h1>
**（需要整理）**

关联知识点：

阅读材料:[https://www.cnblogs.com/senshaw/p/11005919.html](https://www.cnblogs.com/senshaw/p/11005919.html)

**sizeof 内存对齐的一些规则:**

1. #pragma pack(n) 预编译指令，可用来设置多少个字节对齐，n的缺省数值是按照编译器自身设置，一般为8，合法的数值分别是1、2、4、8、16,其它的无效。
2. offset从0开始，每个数据成员开始存放的offset值为min(n, 数据成员大小)的整数倍。
3. 在数据成员完成各自的存放之后，整个类也将进行内存对齐，其大小为min(n, 整个类中最大成员的大小)的整数倍。

**sizeof的大小受到三个因素的影响：**

1. 语言本身所造成的额外负担（vptr、vbptr（有些编译器有，也有可能会共用vptr））
2. 编译器对于特殊情况所提供的优化处理（如空类）
3. 内存对齐的限制

```cpp
class X {};
class Y: public virtual X {};
class Z: public virtual X {};
class A: public Y, public Z {};
int main()
{
    cout << sizeof(X) << endl; //1
    cout << sizeof(Y) << endl; //4
    cout << sizeof(A) << endl; //8
    return 0;
}
```

**C++空基类优化**

**<font style="color:#db7800;">空类的大小是多少？</font>**

<h6 id="26b9587d">**空基类优化（EBCO）**</h6>
阅读材料:[https://blog.csdn.net/weixin_46645965/article/details/136779767?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522172424448416800178541517%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=172424448416800178541517&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-5-136779767-null-null.142^v100^pc_search_result_base4&utm_term=%E7%A9%BA%E5%9F%BA%E7%B1%BB%E4%BC%98%E5%8C%96&spm=1018.2226.3001.4187](https://blog.csdn.net/weixin_46645965/article/details/136779767?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522172424448416800178541517%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=172424448416800178541517&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-5-136779767-null-null.142^v100^pc_search_result_base4&utm_term=%E7%A9%BA%E5%9F%BA%E7%B1%BB%E4%BC%98%E5%8C%96&spm=1018.2226.3001.4187)

<h6 id="f9a10df7">**1.1 继承体系中的内存模型**</h6>
<u>如果一个类是空类，即里面无任何数据成员，那么它会有一个隐藏的1 byte 大小，那是被编译器安插进去的一个char，这使得两个objects得以在内存中配置独一无二的地址。</u>

子类继承父类，可以等效地看作子类将父类的成员变量复制到自己内存模型中。

```cpp
class Allocator{};
class DequeImpl:public Allocator {
public: DequeImpl():size_(0){}
private: int size_;
};
class DequeImpl1:public Allocator {};
class DequeImpl2:public DequeImpl1 {};
int main() {
    DequeImpl dequeImpl; DequeImpl1 dequeImpl1; DequeImpl2 dequeImpl2;
    std::cout<<"Size of DequeImpl:" << sizeof(dequeImpl) << std::endl;//4
    std::cout<<"Size of DequeImpl1:" << sizeof(dequeImpl1) << std::endl;//1
    std::cout<<"Size of DequeImpl2:" << sizeof(dequeImpl2) << std::endl;//1
    return 0;
}
```

```cpp
#include <iostream>
class Allocator{};
class DequeImpl : public Allocator {
public: DequeImpl():size_(0){}
private: int size_;
};
class DequeImpl1 : public Allocator {};
class DequeImpl2 : public DequeImpl1 {};
class DequeImpl3 : public DequeImpl1,DequeImpl2 {};
int main() {
    DequeImpl dequeImpl; DequeImpl1 dequeImpl1; DequeImpl2 dequeImpl2;
    DequeImpl3 dequeImpl3;
    std::cout<<"Size of DequeImpl:" << sizeof(dequeImpl) << std::endl;//4
    std::cout<<"Size of DequeImpl1:" << sizeof(dequeImpl1) << std::endl;//1
    std::cout<<"Size of DequeImpl2:" << sizeof(dequeImpl2) << std::endl;//1
    std::cout<<"Size of DequeImpl3:" << sizeof(dequeImpl3) << std::endl;//2??
    return 0;
}
```

<h1 id="99d7e84d">Function 语意学</h1>
💡

关联知识点：

const和指针 [https://kdocs.cn/l/cdG2hX3TcAWz?linkname=MNO8gr7HLU](https://kdocs.cn/l/cdG2hX3TcAWz?linkname=MNO8gr7HLU)

**<font style="color:#db7800;">对象如何调用非静态成员函数的(非const和const)?</font>****<font style="color:#db7800;">什么是</font>****<font style="color:#db7800;">名称的特殊处理(Name Mangling)?避免虚函数机制开销有哪些方法？静态成员函数是如何调用的？</font>**

<h4 id="a2cfa946">成员函数的各种调用方式</h4>
<h5 id="fa7a05de">非静态成员函数</h5>
<u>使用C++时，成员函数和非成员函数在性能上应该是等价的。当设计类时，我们不应该因为担心效率问题而避免使用成员函数。 </u>

<u>实现：</u><u>编译器会将成员函数转换为一个带有额外this指针参数的非成员函数，这使得成员函数可以直接访问对象的数据成员。</u>

<u>成员函数到非成员函数的转换</u>

<u>签名修改：首先，成员函数的签名会被修改，在最前面添加一个隐式的this指针作为参数。如果成员函数是const的，那么this指针也会是const。</u>

非const成员函数：

```cpp
float Point3d::magnitude() { ... }
```

转换后:

```cpp
float Point3d::magnitude(Point3d *const this) { ... }
```

const成员函数:

```cpp
float Point3d::magnitude() const { ... }
```

转换后:

```cpp
float Point3d::magnitude(const Point3d *const this) { ... }
```

<u>通过this指针存取数据成员：接下来，所有对非静态数据成员的直接访问都会被替换为通过this指针的间接访问。 </u>

```cpp
return sqrt(_x*_x +_y*_y + _z*_z);
```

会被转换为

```cpp
return sqrt(this->_x * this->_x + this->_y * this->_y + this->_z * this->_z);
```

<u>名称修饰：最后，成员函数的名称会被进行“名称修饰”(name mangling)，以确保它在整个程序中的唯一性。这样可以支持重载和其他语言特性。</u>

假设原始的成员函数是：

```cpp
float Point3d::magnitude() const;
```

编译器可能会生成如下形式的外部函数：

```cpp
extern "C" float __Z9magnitudeRK7Point3d(const Point3d *const this);
```

调用转换：对于每个成员函数调用，编译器会生成相应的代码来传递当前对象的地址作为this指针。

对象直接调用：

```cpp
obj.magnitude();
```

变为

```cpp
__Z9magnitudeRK7Point3d(&obj);
```

指针调用:

```cpp
ptr->magnitude();
```

变为：

```cpp
__Z9magnitudeRK7Point3d(ptr);
```

优化例子

考虑一个归一化向量的成员函数：

```cpp
Point3d Point3d::normalize() const {
    float mag = magnitude();
    return Point3d(_x / mag, _y / mag, _z / mag);
}
```

这个函数可能被转换成类似下面的形式（假设已经进行了NRV优化）

```cpp
void normalize__7Point3dFv(register const Point3d *const this, Point3d &result) {
    register float mag = this->magnitude(); // 使用了转换后的magnitude函数
    new (&result) Point3d(this->_x / mag, this->_y / mag, this->_z / mag); // 直接构造
}
```

&result代表了返回值的位置,new (&result)是放置新对象的原地构造(placement new)，这样做避免了默认构造函数的开销，并且直接创建了归一化后的Point3d对象。

<h5 id="59ae063a">名称的特殊处理(Name Mangling)</h5>
<u>名称修饰(name mangling)将函数和成员变量的名称转换为唯一的内部表示形式。这样做为了支持重载、类成员访问以及跨模块链接时的类型安全。解决同名问题：当一个基类和派生类中存在同名成员时，编译器需要一种方式来区分它们。</u>

<u>支持函数重载：即使两个函数具有相同的名字，只要它们的参数列表不同，编译器也需要能够生成不同的内部名称。</u>

<u>确保类型安全链接：通过将函数签名编码进名称中，可以防止链接时由于类型不匹配导致的错误。</u>

考虑以下类定义：

```cpp
class Bar {
public:
int ival;
};
class Foo：public Bar {
    public:
    int ival; // 与Bar::ival同名
};
```

Foo对象包含了一个Bar的实例和一个自己的ival。

为了区分这两个ival，编译器可能会对它们进行名称修饰如：

Bar::ival 可能被修饰为 ival__3Bar，Foo::ival 可能被修饰为 ival__3Foo。这使每个成员都有一个唯一的名字，避免了命名冲突。

对于成员函数，尤其是重载的成员函数，名称修饰更加复杂。因为除了类名外，还需要包括函数的参数类型信息。

```cpp
class Point {
public:
void x(float newX);
float x();
};
```

编译器可能将这些函数修饰为：

```cpp
void x__5PointFf(float newX); (5是Point的长度，Ff表示有一个float参数）
    float x__5PointFv(); （Fv表示没有参数）
```

这确保即使函数名字相同，只要参数列表不同，就会有不同的内部名称。

类型安全链接

名称修饰有助于在链接阶段进行有限的形式类型检查。如果有一个print函数定义如下：

```cpp
void print(const Point3d& p) { ... }
```

而用户意外地声明并调用它为：

```cpp
// 错误的声明
void print(const Point3d* p);
```

由于名称修饰的不同，链接器会发现无法解析这个函数调用，从而报错。这称为“类型安全链接”（type-safe linkage）。这种机制只能检测函数签名（即名称、参数个数和类型）的错误，而不能检测返回类型的错误。

**显式调用虚函数以避免虚函数机制开销**

如果在同一个类的方法中调用另一个虚函数，并且已经知道具体的类型，可以直接调用该函数，而不是通过虚函数机制。如在 Point3d::normalize() 中调用 magnitude() 时，直接调用 Point3d::magnitude() 会更高效，因为它避免了查找vtable的过程。

```cpp
register float mag = Point3d::magnitude();
```

**内联虚函数**

<u>如果虚函数被声明为内联，编译器可以直接展开函数体，从而进一步提高性能。如果 magnitude() 是内联的，那么在 normalize() 中调用它时，编译器可以直接将 magnitude() 的代码嵌入到 normalize() 中，避免了虚函数机制的开销。</u>

**对象直接调用虚函数**

<u>对于直接通过对象调用虚函数的情况，编译器可以进行优化，直接调用具体类型的函数，而不是通过虚函数表。如对于 obj.normalize();，编译器可以直接调用 Point3d::normalize()，而不需要通过 vptr 查找vtable。</u>

```cpp
normalize__7Point3dFv(dobj);
```

假设我们有以下类定义：

```cpp
class Point3d {
public:
float _x, _y, _z;
virtual float magnitude() const {
    return sqrt(_x * _x + _y * _y + _z * _z);
}
virtual void normalize() const {
    float mag = magnitude();
    // 归一化逻辑
}
};
```

通过基类指针调用

```cpp
Point3d* ptr = new Point3d();
ptr->normalize();
```

显式调用虚函数

在 normalize() 中调用 magnitude() 时，直接调用 Point3d::magnitude() 会更高效：

```cpp
void Point3d::normalize() const {
    float mag = Point3d::magnitude();  // 直接调用，避免虚函数机制
    // 归一化逻辑
}
```

内联虚函数

如果 magnitude() 被声明为内联函数：

```cpp
inline float Point3d::magnitude() const {
    return sqrt(_x * _x + _y * _y + _z * _z);
}
```

在 normalize() 中调用时，编译器可以直接展开 magnitude() 的代码，进一步提高效率

```cpp
void Point3d::normalize() const {
    float mag = sqrt(_x * _x + _y * _y + _z * _z);  // 直接展开
    // 归一化逻辑
}
```

<h5 id="5068e4f0">Static Member Functions(静态成员函数)</h5>
静态成员函数

<u>在C++中，静态成员函数（static member functions）是一种特殊的成员函数，它们不依赖于类的任何特定实例。静态成员函数的主要特性是没有 this 指针，因此不能直接访问类的非静态成员。</u>

调用静态成员函数

假设 Point3d::normalize() 是一个静态成员函数，那么以下两种调用方式：

```cpp
obj.normalize();
ptr->normalize();
```

<u>静态成员函数没有 this 指针，不能直接访问类的非静态成员。</u>不<u>能被声明为 const、volatile 或 virtual。静态成员函数可以通过类名直接调用，也可以通过类的对象调用，但通常是直接通过类名调用。</u>

<u>表达式求值：</u>

<u>如果静态成员函数是通过某个表达式获得的类对象调用，该表达式仍然会被评估。</u>

```cpp
if (foo().object_count() > 1)
```

<u>会被转换为：</u>

```cpp
(void) foo();  // 评估表达式以保存副作用
if (Point3d::object_count() > 1) ...
```

<u>内部转换</u>

<u>静态成员函数在编译器内部会被转换为一个普通的非成员函数。</u>

```cpp
unsigned int Point3d::object_count() {
    return _object_count;
}
```

会被 cfront 编译器转换为：

```cpp
unsigned int object_count__5Point3dSFv() {
    return _object_count__5Point3d;
}
```

其中 SFv 表示这是一个静态成员函数，拥有一个空的参数列表。

<u>取地址</u>

<u>取静态成员函数的地址时，得到的是其在内存中的位置。由于静态成员函数没有 this 指针，所以其地址的类型是一个普通函数指针，而不是指向类成员函数的指针。</u>

```cpp
auto func = &Point3d::object_count;
```

func 的类型将是：

```cpp
unsigned int (*)();
```

而不是unsigned int (Point3d::*)();

<h5 id="cc2748e4">virtual Member Functions(虚成员函数)</h5>
执行期类型判断：

为了支持多态，必须能够在运行时确定对象的实际类型。

```cpp
ptr->z();
```

编译器需要在运行时知道 ptr 指向的对象类型，以便调用正确的 z() 函数实例。最直接但成本最高的方法是将必要的信息附加到指针上。这会导致空间开销增加，并且破坏与C语言的兼容性。更好的方法是将这些信息存储在对象本身。然而并不是所有的类都需要这些信息。

简单的C结构体如 struct date { int m, d, y; }; 并不需要额外的信息。为了识别哪些类需要额外的运行时信息，最合理的方法是检查类是否包含任何虚函数。只要类有一个虚函数，它就需要这些额外的运行时信息。class 和 struct 不能帮助我们区分,它们在语法上是等价的,因此唯一适当的方法是查看类是否有虚函数。

存储的信息：对于每个多态对象，需要存储两个信息：

类型标识：一个字符串或数字，表示类的类型。

虚函数表指针：指向一个表格，该表格包含程序中的虚函数的运行时地址。

虚函数表的构建：虚函数表在编译时构建，其大小和内容在运行时不会改变。编译器完全控制虚函数表的构建和访问。每个类只有一个虚函数表，包含所有活跃的虚函数实例的地址。

纯虚函数的空间占位符，通常是 pure_virtual_called() 函数，用于处理纯虚函数的调用。

虚函数调用：每个虚函数被分配一个固定的索引值，这个索引在整个继承体系中保持一致。

例如，在 Point 类体系中：

```cpp
#include <iostream>

class Point {
public:
// 虚析构函数，确保派生类对象能够正确释放资源
virtual ~Point() {}

// 纯虚函数，使得Point成为一个抽象类
virtual Point* mult(float) = 0;

// 获取x坐标
float x() const { return _x; }

// 默认的y坐标为0，可以被派生类重写
virtual float y() const { return 0.0f; }
// 默认的z坐标为0，可以被派生类重写
virtual float z() const { return 0.0f; }
protected:
// 构造函数，默认x坐标为0
Point(float x = 0.0f) : _x(x) {}
// x坐标私有变量
float _x;
};

// 2D点类，继承自Point
class Point2d : public Point {
public:
// 构造函数，默认x和y坐标为0
Point2d(float x = 0.0f, float y = 0.0f) : Point(x), _y(y) {}
// 析构函数
~Point2d() override {}
// 重写mult方法
Point2d* mult(float scalar) override {
    return new Point2d(_x * scalar, _y * scalar);
}
// 重写y方法
float y() const override { return _y; }
protected:
// y坐标私有变量
float _y;
};

// 3D点类，继承自Point2d
class Point3d : public Point2d {
public:
// 构造函数，默认x、y和z坐标为0
Point3d(float x = 0.0f, float y = 0.0f, float z = 0.0f) : Point2d(x, y), _z(z) {}
// 析构函数
~Point3d() override {}
// 重写mult方法
Point3d* mult(float scalar) override {
    return new Point3d(_x * scalar, _y * scalar, _z * scalar);
}
// 重写z方法
float z() const override { return _z; }
protected:
// z坐标私有变量
float _z;
};
```

虚析构函数被分配槽位1，mult() 被分配槽位2，但由于它是纯虚函数，实际存放的是pure_virtual_called()的地址，y() 被分配槽位3，z() 被分配槽位4，x()不是虚函数，因此没有槽位。

调用转换：编译器将虚函数调用转换为对虚函数表的访问。例如，ptr->z(); 被转换为：

```cpp
(*ptr->vptr[4])(ptr);
```

其中 vptr 是指向虚函数表的指针，4 是 z() 在虚函数表中的索引。

**单一继承**

在单一继承的情况下，虚函数机制表现良好，既有效率又容易建模。每个派生类会扩展基类的虚函数表，并添加自己的虚函数。

![](https://cdn.nlark.com/yuque/0/2025/png/45533403/1742810994203-251a1824-170f-48ac-9f31-e31753595da6.png)

**多重继承**

在多重继承的情况下，事情变得复杂一些。每个基类都有自己的虚函数表，派生类需要维护多个虚函数表指针。为了支持多态，编译器需要确保通过任何基类指针都能正确地调用派生类的虚函数。

```cpp
//基类 Basel
class Basel {
public:
// 构造函数
Basel() : data_Basel(0.0f) {}
// 虚析构函数
virtual ~Basel() {}
// 纯虚函数，使得Basel成为一个抽象类
virtual void speakClearly() = 0;
// 克隆方法
virtual Basel* clone() const = 0;
protected:
// 数据成员
float data_Basel;
};
// 另一个基类 Base2
class Base2 {
public:
// 构造函数
Base2() : data_Base2(0.0f) {}
// 虚析构函数
virtual ~Base2() {}
// 纯虚函数，使得Base2成为一个抽象类
virtual void mumble() = 0;
// 克隆方法
virtual Base2* clone() const = 0;
protected:
// 数据成员
float data_Base2;
};
// 派生类 Derived，继承自两个基类
class Derived : public Basel, public Base2 {
public:
// 构造函数
Derived() : data_Derived(0.0f) {}
// 虚析构函数
virtual ~Derived() {}
// 实现 Basel 的纯虚函数
void speakClearly() override {
    std::cout << "Derived speaking clearly" << std::endl;
}
// 实现 Base2 的纯虚函数
void mumble() override {
    std::cout << "Derived mumbling" << std::endl;
}
// 实现克隆方法
Derived* clone() const override {
    return new Derived(*this);
}
protected:
// 数据成员
float data_Derived;
};
```

当一个派生类从多个基类继承时，基类中包含虚函数，编译器需要指针调整。当通过基类指针删除派生类对象时，必须调用正确的虚析构函数。如果Base2是Derived的一个基类，并且pbase2指向Derived对象，那么通过delete pbase2，删除对象时，编译器需要确保调用的是Derived的析构函数，而不是Base2的析构函数。

为了支持这一点，编译器会在Base2的虚表（vtable）中放置一个指向Derived析构函数的指针。这样，即使pbase2是一个Base2*类型的指针，它也会调用Derived的析构函数，从而正确地清理Derived对象。

当通过Base2*指针调用mumble()方法时，如果mumble()是虚函数，那么编译器会使用Base2的虚表来找到实际要调用的方法。但是，由于Derived是从Base2继承而来的，它的内存布局可能与Base2不同，因此this指针需要调整到正确的偏移位置，以便指向Derived对象中的Base2子对象。

虚拟基类指针调整：在虚函数表中存储一个偏移量，用于调整this指针。这样，即使通过基类指针调用虚函数，也能找到正确的派生类方法。

隐藏的调整代码：编译器生成一些额外的代码，在调用虚函数之前调整this指针。这种调整通常是通过添加或减去一个固定的偏移量来完成的。

Bjarne Stroustrup 在 cfront 中的做法

Bjarne Stroustrup 在早期的 C++ 编译器 cfront 中采取了一种方法，即扩展虚表（vtable），使其不仅包含虚函数的地址，还包含了一个偏移量。这样，每个虚表条目变成了一个结构体，包含函数地址(faddr)和偏移量(offset)。

例如：

原本的虚表条目可能是这样的：void (Base2::*fptr)()。

扩展后的虚表条目则是这样的：struct { void (*faddr)(); int offset; }。

当通过Base2*指针调用虚函数时，编译器会执行以下操作：从pbase2->vptr[1]获取结构体。使用pbase2 + vptr[1].offset来调整this指针。调用(*vptr[1].faddr)(pbase2 + vptr[1].offset)；

这样做以确保即使通过基类指针调用虚函数，也能正确地调整this指针，从而调用派生类中的相应方法。

**缺点：**

所有的虚函数调用都需要额外的开销，即使不需要调整this指针，这包括了额外内存访问(读取偏移量)和额外的加法操作(调整this指针)，此外每个虚表条目的大小也增加了，导致更多的内存占用。通常采用更优化的方法来处理这种情况，比如只对需要调整this指针的虚函数进行特殊处理，而不是对所有虚函数都做这种调整。这样可以在不牺牲性能的情况下支持多重继承和虚函数。

![](https://cdn.nlark.com/yuque/0/2025/png/45533403/1742810994214-ba3b3498-1c70-4595-afd6-6e2703ac98fc.png)

**Thunk 技术**

Thunk 是一小段汇编代码，它用于在调用虚函数之前调整this指针。

（1）调整 this 指针：根据基类子对象在派生类中的偏移量，调整this指针。

（2）跳转到虚函数：将控制权转移到实际的虚函数。

假设有一个派生类 Derived 继承自两个基类 Base1 和 Base2，并且通过 Base2* 指针删除 Derived 对象。相关的 thunk 可能看起来像这样：

```cpp
// 虚拟 C++ 代码
pbase2_dtor_thunk:
this += sizeof(Base1);  // 调整 this 指针
Derived::~Derived(this);  // 跳转到 Derived 的析构函数
```

编译器实现

Bjarne Stroustrup 在早期的 cfront 编译器中没有使用 thunk 技术，主要是因为 cfront 使用 C 作为中间语言，而 C 语言无法高效地生成高效的 thunk 代码。现代编译器通常可以直接生成高效的 thunk 代码，从而避免了额外的空间和性能开销。

Virtual Table Slots

为了支持多重继承，每个基类都有自己的虚表（vtable）。每个虚表槽（slot）可以包含两种类型的地址：

直接指向虚函数：如果不需要调整 this 指针。

指向一个 thunk：如果需要调整 this 指针。

```cpp
Base1 *pbase1 = new Derived;
Base2 *pbase2 = new Derived;
delete pbasel; // 不需要调整 this 指针
delete pbase2;  // 需要调整 this 指针
```

在这种情况下，Derived 类会有两个虚表：

主要虚表：与 Base1 共享，不需要调整 this 指针。

次要虚表：与 Base2 关联，需要调整 this 指针。

为什么要调整this指针？

多个虚表

对于每个虚表，Derived 对象中有对应的 vptr。这些 vptr 在构造函数中初始化。例如，Derived 对象可能有如下布局：vptr1 指向主要虚表 vtbl_Derived。vptr2 指向次要虚表 vtbl__Base2__Derived。

主要虚表：

vtbl_Derived Derived 对象通过 Base1* 或 Derived* 指针访问时使用。直接指向虚函数或指向不需要调整 this 指针的 thunk。

次要虚表

vtbl__Base2__Derived。当 Derived 对象通过 Base2* 指针访问时使用。直接指向虚函数或指向需要调整 this 指针的 thunk。

构造函数中的初始化：在构造函数中，编译器会生成代码来初始化这些 vptr。

```cpp
Derived::Derived() {
    // 初始化 vptr1 指向主要虚表
    vptr1 = &vtbl_Derived;
    // 初始化 vptr2 指向次要虚表
    vptr2 = &vtbl__Base2__Derived;
}
```

**虚拟继承**

在虚拟继承的情况下，虚函数机制变得更加复杂。虚基类共享同一个虚函数表，派生类需要处理复杂的虚函数表布局，以确保正确的虚函数被调用。

```cpp
class Point2d {
public:
//构造函数，默认参数为0.0
Point2d(float x = 0.0, float y = 0.0) : x_(x), y_(y) {}
//虚析构函数
virtual ~Point2d() {}
//纯虚函数mumble，需要在派生类中实现
virtual void mumble() = 0;
//纯虚函数z，需要在派生类中实现
virtual float z() const = 0;
protected:
// 保护成员变量x_和y_
float x_, y_;
};
//Point3d继承自Point2d，使用虚继承
class Point3d : public virtual Point2d {
public:
//构造函数，默认参数为0.0
Point3d(float x=0.0,float y=0.0, float z=0.0):Point2d(x, y), z_(z) {}
// 析构函数
~Point3d() override {}
// 实现基类中的纯虚函数z
float z() const override {
    return z_;  // 返回z坐标值
}
// 如果需要的话，这里也可以实现mumble()方法
private:
// 私有成员变量z_
float z_;
};
```

![](https://cdn.nlark.com/yuque/0/2025/png/45533403/1742810994220-0ab59bad-13d9-4fd9-adca-51d592e9b392.png)

虚拟继承与非虚拟继承的区别：

在非虚拟的单一继承中，派生类对象的内存布局是直接包含基类子对象，派生类对象可以直接转换为基类对象指针，而不需要调整this指针。虚拟继承是为了处理多重继承中的菱形问题（即一个类从多个基类派生，这些基类又共享一个共同的基类）。在虚拟继承的情况下，编译器确保派生类只保留一份共同基类的实例。这会导致派生类对象和基类对象之间的内存布局有所不同（？）。

调整this指针：当使用虚拟继承时，由于基类可能不是位于派生类对象的开始位置，因此当通过基类指针访问派生类成员时，编译器需要对this指针进行调整。

如果虚拟基类也包含虚函数和非静态数据成员，那么内存布局会变得更加复杂。每个派生类都需要维护指向虚拟基类的指针，并且这些指针的位置以及如何通过它们找到实际的数据成员变得非常棘手。

编译器需要计算正确的偏移量来定位这些数据成员。

建议避免的做法：不要在虚拟基类中声明非静态数据成员。简化内存布局，减少编译器的工作负担，并降低程序出错的可能性。如果确实需要数据成员，可以在派生类中定义，或者考虑重新设计类层次结构以**<u>避免使用虚拟继承。</u>**

（虚函数调用的细节暂时不看。）

<h4 id="9e83eab6">函数的效能</h4>
<u>（1）非成员函数的性能</u>

<u>非成员函数的调用效率很高，它们不涉及对象的状态和虚拟机制的开销。由于实现简单，编译器可以进行优化。</u>

<u>（2）内联函数</u>

<u>未优化的内联函数提高了约25%的效率，而优化后的内联函数表现极为出色。编译器可以将不变的表达式移出循环，从而减少不必要的计算，这一优化提升了性能。</u>

<u>（3）虚拟函数的开销</u>

<u>虚拟函数调用相较于非虚拟函数，存在额外的开销。这是由于虚拟函数的实现需要通过虚拟表（vtable）和虚拟指针（vptr）进行查找。每次虚拟函数的调用都会涉及到指针的调整和查找，从而导致性能下降。</u>

<u>（4）继承的影响</u>

<u>在单继承的情况下，每增加一层继承，虚拟函数的执行时间明显增加。这是因为每层继承都可能导致额外的构造函数调用，特别是涉及到虚拟函数的构造，这会导致对</u>`<u>this</u>`<u>指针的设置。</u>

<u>（5）构造函数的额外开销</u>

<u>由于每个构造函数都可能包含对</u>`<u>this</u>`<u>指针的测试，有多个继承层次时，这种开销会积累并显著影响性能。虽然现代编译器已经优化了内存管理，但仍然保留了一些过时的兼容性检查，导致性能下降。</u>

<u>（6）局部对象的构造开销</u>

<u>使用局部对象会导致频繁调用构造函数，即使该对象未被使用。通过消除局部对象的使用，避免了构造函数的调用，可以进一步提高性能。</u>

<h4 id="305804ed">指向成员函数的指针</h4>
📌

关联知识点：

函数指针 [https://kdocs.cn/l/cdG2hX3TcAWz?linkname=wjOCznohy3](https://kdocs.cn/l/cdG2hX3TcAWz?linkname=wjOCznohy3)

1. <u>非静态数据成员的地址：当获取一个非静态数据成员的地址时，得到的结果实际上是该成员在类布局中的位置，加上一个偏移量（通常是1）。这个地址表明这个成员在对象中的相对位置，但并不指向一个具体的对象实例。因此，这个地址是不完整的，因为它不能被直接使用来访问该数据成员。需要将其与具体对象的地址结合起来，才能访问该成员。</u>
2. **<u>非静态成员函数的地址：对于非静态成员函数，获取其地址会得到它在内存中的真实地址，但同样这个地址是“不完整”的。虽然可以通过这个地址直接调用函数，但非静态成员函数在调用时需要一个隐式的参数</u>**`**<u>this</u>**`**<u>，它指向调用该函数的对象实例。这意味着，尽管你获得了函数的地址，但在实际调用时仍需绑定到一个对象上才能生效。</u>**

`<u>this</u>`<u>指针的作用：所有非静态成员函数在调用时都会自动传入</u>`<u>this</u>`<u>指针。因此，当通过获取函数地址来调用它时，需要将</u>`<u>this</u>`<u>指针传递给函数，以确保函数能够正确访问和操作该对象的成员。</u>

**指向成员函数指针的声明与使用**

声明语法

```cpp
return_type(class_name::*pointer_name)(argument_list);
```

`return_type`成员函数的返回类型。`class_name`函数所属的类。`pointer_name`指针名称。`argument_list`参数列表。

```cpp
#include <iostream>
using namespace std;
class Point {
public:
Point(double a, double b) : x(a), y(b) {}
double x() { return x; }
double y() { return y; }
private:
double x;
double y;
};
int main() {
    // 1. 声明指向成员函数的指针
    double (Point::*p)();  // 声明一个指向Point类成员函数的指针，返回类型为double，无参数
    // 2. 定义与初始化
    p = &Point::x;  // 指向Point类的x成员函数s
    // 3. 创建对象
    Point o(3.0, 4.0);
    // 4. 使用对象调用成员函数
    cout << "X: " << (o.*p)() << endl;  // 输出: X: 3
    // 5. 改变指针指向的成员函数
    p = &Point::y;  // 现在指向Point类的y成员函数
    // 6. 使用对象调用成员函数
    cout << "Y: " << (o.*p)() << endl;  // 输出: Y: 4
    // 7. 使用指针调用成员函数
    Point* q = &o;
    cout << "Y: " << (q->*p)() << endl;  // 输出: Y: 4 (因为p现在指向y)
    return 0;
}
```

<u>静态成员函数是属于类本身而不是某个特定对象的。它们可以被类直接调用，而不需要创建对象实例。由于静态成员函数不与任何对象实例关联，它们没有</u>`<u>this</u>`<u>指针。在调用静态成员函数时，不需要一个对象的上下文。由于没有</u>`<u>this</u>`<u>指针，静态成员函数的类型可以被视为普通函数指针。</u>

<h5 id="9e818d67">支持“指向 Virtual Member Functions”的指针</h5>
虚拟机制仍然能在使用 "指向 member function指针" 的情况下运行。

```cpp
class Point {
public:
virtual ~Point();        // 虚拟析构函数
float x();               // 非虚拟成员函数
float y();               // 非虚拟成员函数
virtual float z();       // 虚拟成员函数
};
// 指向成员函数的指针，能够指向 Point 类中的成员函数
float (Point::*pmf)() = &Point::z;  // 指向虚拟函数 z 的指针
// 创建一个 Point3d 对象(假设它是 Point 的派生类)
Point* ptr = new Point3d;
// 直接调用虚拟成员函数
ptr->z();  // 调用的是 Point3d::z()
// 通过指向成员函数的指针间接调用虚拟成员函数
(ptr->*pmf)();  // 仍然调用 Point3d::z()
```

编译器在处理指向虚拟成员函数的指针时，可能会将调用转化为以下形式：

```cpp
// 假设pmf指向虚拟函数z的索引
(*ptr->vptr[(int)pmf])(ptr); //调用虚拟函数
```

对于非虚拟成员函数（如 `x()` 和 `y()`)，获取地址的方法如下：

```cpp
float (Point::*pmf1)() = &Point::x;  // 指向非虚函数 x 的指针
float (Point::*pmf2)() = &Point::y;  // 指向非虚函数 y 的指针
```

**编译器如何处理指向成员函数的指针**

为了能够在一个指针中存储虚拟函数的索引和非虚拟函数的地址，编译器需要一些技巧。例如，cfront 2.0(第一个C++编译器)使用了一个普通指针，并通过某种方式（如位运算）区分该指针是指向内存地址还是虚拟表索引。通过将指针转为整数，并与127进行位运算，来判断是虚拟函数调用还是非虚拟函数调用。如果该值小于128，则认为是指向非虚拟函数的地址；如果大于128，则将其视为虚拟函数的索引。

```cpp
if (((int)pmf) & 127) {//非虚拟调用
    (*pmf)(ptr);
}else{ //虚拟调用
    (*ptr->vptr[(int)pmf])(ptr);
}
```

假设有一个类`Point`，定义了虚拟成员函数`z()`和非虚拟成员函数`x()`。`pmf`指向`Point::z()`，在调用`(ptr->*pmf)()`时，编译器会查找`ptr`的虚拟表，根据`pmf`中的索引找到对应的虚拟函数地址并调用。如果指向的是`x()`，则直接调用其地址。

<h4 id="103be97b">inline函数</h4>
📌

关联知识点：

GNU C 属性awalys_inline和no_inline

`x()`和`y()`函数被声明为`inline`

直接在调用点展开代码，可以避免函数调用的开销。仍然可以控制对私有数据成员的访问，保持数据封装的原则。虽然`inline`函数提供了性能优势，但并不是所有函数都能强制为`inline`。

+ **<u>编译器的决定</u>**<u>：使用</u>`<u>inline</u>`<u>只是一个建议，编译器可以选择不展开函数，尤其是在函数复杂度过高或不适合展开时。在调用时，如果传递的参数或临时对象使得</u>`<u>inline</u>`<u>扩展成本高于正常调用，编译器同样会选择不扩展。</u>
+ **<u>链接问题</u>**<u>：如果</u>`<u>inline</u>`<u>函数未被展开，可能会生成多个相同的函数实例，导致代码膨胀。虽然链接器会尝试去重，但不是所有链接器都能有效地处理。</u>

<h5 id="e7e1bace">inline的副作用</h5>
调用`inline`函数时，形式参数会被实际参数替代。如果实际参数是一个有副作用的表达式，比如函数调用或修改变量的操作，可能会导致多次求值，从而引入不必要的复杂性。编译器可以直接将结果替换为常量，因为常量不需要求值。

`**min(foo(), bar() + 1)**`

如果`foo()`修改了某个全局变量。多次调用 `foo()` 的情况通常是指在表达式中重复使用相同的函数，

```cpp
min(foo(), foo() + 1);
```

在这个例子中，`foo()` 被调用了两次：第一次调用 `foo()` 会使 `globalVar`增加 1。第二次调用 `foo()` 又会使 `globalVar` 再次增加 1。如果 `foo()` 是这样的一个函数，每次调用都会修改 `globalVar`的值，那么最终 `globalVar`的值会因为被调用两次而发生两次变化，导致结果不一致。

（避免这种情况）

<h5 id="e0ec0c16">局部变量的影响</h5>
**唯一性**：每个 `inline` 函数中的局部变量必须有一个独一无二的名称。如果该 `inline` 函数被多次扩展，每次扩展都需要自己的局部变量。这是为了确保每次调用的局部变量不会相互干扰。

**封闭作用域**：局部变量在函数调用的一个封闭区段中存在，有自己的作用域。因此，即使在多个地方调用 `inline` 函数，它们的局部变量也不会相互冲突。

如果一个 `inline` 函数被调用太多次，尤其是其中有副作用的参数，可能导致程序大小迅速增加。这是因为每次调用都会生成新的扩展代码，尤其是在复杂的 `inline` 函数中，局部变量会导致更多的临时对象。<u>如果 </u>`<u>inline</u>`<u> 函数中还包含其他的 </u>`<u>inline</u>`<u> 函数调用，可能会导致更复杂的调用链，这样的链条可能无法被编译器有效地扩展。</u>

<h1 id="3afa4c64">构造、析构、拷贝语意学</h1>
**<font style="color:#db7800;">什么是纯虚函数？为什么尽量把析构函数声明为普通虚函数而不是纯虚函数？为什么要把析构函数写成虚函数？什么时候不用虚函数？const修饰成员函数有什么注意的？全局对象、局部对象、堆对象如何构造的？构造函数的执行步骤是什么？</font>**

<h4 id="798b233f">**纯虚函数**</h4>
<u>定义：纯虚函数通常用于定义一个接口，要求派生类必须实现该函数。</u>

<u>调用：尽管纯虚函数不能通过虚拟机制调用，但可以在派生类中静态地调用基类的纯虚函数实现。</u>

**静态调用纯虚函数：**

合法性：<u>在派生类中，可以通过 BaseClass::function() 的方式静态调用基类的纯虚函数。</u>

**为什么纯虚函数可以有具体实现？**

<u>根据 C++ 标准，纯虚函数可以有具体的实现。声明为纯虚函数的主要目的是强制派生类实现该函数，但并不禁止基类提供一个默认实现</u>。<u>纯虚函数的声明形式为 virtual void func() = 0;但这并不妨碍在类体外提供一个实现。提供纯虚函数的具体实现可以增加设计的灵活性。基类可以提供一个默认行为，派生类可以选择覆盖这个行为或使用默认实现。</u>

<h5 id="d3d58f2b">**纯虚析构函数：**</h5>
<u>必要性：纯虚析构函数必须提供一个定义。这是因为派生类的析构函数会被编译器扩展，以静态调用的方式调用其每一个虚基类和上一层基类的析构函数。</u>

示例：Abstract_base 的纯虚析构函数必须提供一个定义。

```cpp
virtual ~Abstract_base() = 0;
Abstract_base::~Abstract_base() {}
```

**为什么纯虚析构函数必须有定义：**

<u>编译器会在派生类的析构函数中插入对基类析构函数的调用。如果基类的析构函数没有定义，会导致链接失败。</u>

**<u>替代方案：</u>**

<u>不要把虚析构函数声明为纯虚：一个更好的设计是将虚析构函数声明为普通虚函数，并提供一个默认实现。</u>

```cpp
class Abstract_base {
public:
virtual ~Abstract_base() {} // 普通虚析构函数
virtual void interface() const = 0; // 纯虚函数
};
```

<h5 id="c7d1ea59">**<u>关于析虚构函数的说明</u>**</h5>
在 C++ 中，如果一个类可能被继承，并且可能会通过基类指针来删除派生类对象，那么基类的析构函数必须是虚函数。否则，只会调用基类的析构函数，而不会调用派生类的析构函数，导致派生类中的资源无法正确释放。将基类的析构函数声明为虚函数后，通过基类指针删除派生类对象时，会先调用派生类的析构函数，再调用基类的析构函数，确保所有资源都能正确释放。

虚析构函数

**基类可能被继承:**如果一个类可能被其他类继承，并且可能会通过基类指针删除派生类对象，那么基类的析构函数应该是虚函数。

**多态基类:**如果一个类被用作多态基类（即通过基类指针或引用来操作派生类对象），那么它的析构函数必须是虚函数。不需要虚析构函数的情况：如果一个类不会被其他类继承或不会被用作多态基类，那么它的析构函数不需要是虚函数。

**合理使用虚函数:**将所有成员函数都声明为虚函数，然后依赖编译器优化来去除不必要的虚函数调用，并不是一个好的设计理念。这种做法不仅增加了编译器的负担，还可能导致性能下降。只有在确实需要多态性的情况下，才应该将函数声明为虚函数。

<h5 id="2f788ced">const修饰成员函数</h5>
<u>const 修饰符用于声明一个成员函数不会修改对象的状态。声明为 const 的函数可以被 const 对象、const 引用和 const 指针调用。如果一个函数没有声明为 const，则不能被 const 对象、const 引用或 const 指针调用。但是在设计抽象基类时，需要考虑子类实例可能被使用的各种情况。一个 const 函数可能会被频繁调用，而且可能被 const 对象调用。如果一个函数被声明为 const，但后来发现子类实例需要修改某个数据成员，这就成为一个问题。修改数据成员的操作违反了 const 修饰符的语义，会导致编译错误或需要使用 mutable 关键字。</u>

<h4 id="da00eca7">全局对象、局部对象、堆对象的构造</h4>
**全局对象 (global) **

```cpp
Point global;
```

Point 程序启动和结束调用构造函数和析构函数会被调用。全局对象的行为类似于 C 语言中的行为)。

**局部对象 (local**

```cpp
Point local;
```

<u>Point的默认构造函数在 local 定义时被调用。默认析构函数在 local 离开作用域时被调用</u>。由于Point 是 POD，编译器不会生成或调用这些 trivial 成员函数(这些函数包括默认构造函数、析构函数、复制构造函数和复制赋值操作符)。局部对象的行为类似于C语言中的行为。如果local 没有被初始化，可能出现野指针(*heap = local)

**堆对象 **

```cpp
Point *heap = new Point;
*heap = local;
delete heap;
```

<u>new Point 会调用 new 运算符，分配内存并返回一个指针。</u><u>默认构造函数</u><u>会在 new 运算符返回的 Point 对象上被调用。*heap = local; 会触发默认拷贝构造函数，但实际上只是位搬移操作。delete heap; 会调用 delete 运算符，释放内存。默认的析构函数会在 delete 运算符调用时被调用</u>。

按值返回局部对象：

```cpp
return local;
```

<u>返回局部对象 local 时，会触发拷贝构造函数的合成，将 local 的值复制到返回值中。</u>

<u>NRV 优化</u>

<u>如果编译器支持命名返回值优化（Named Return Value, NRV），函数 foobar 会被优化为。</u>

<h4 id="6dfce0ab">构造函数的执行步骤是什么？</h4>
当定义一个对象 T object; 时，构造函数会被调用。

构造函数调用步骤：

<u>（1）成员初始化列表</u>

<u>成员初始化列表中指定的成员变量会被初始化，并按照成员变量在类中声明的顺序进行。如果成员变量没有在初始化列表中出现，但有默认构造函数，则默认构造函数会被调用。</u>

<u>（2）虚指针初始化</u>

<u>如果类有虚拟表指针（vptr），它必须被初始化，指向适当的虚拟表（vtable）。</u>

<u>（3）基类构造函数调用</u>

<u>所有基类的构造函数必须按基类声明的顺序被调用。如果基类在成员初始化列表中列出，显式指定的参数会传递给基类构造函数。如果基类没有在成员初始化列表中列出，但有默认构造函数，则默认构造函数会被调用。</u>

<u>虚基类构造函数调用</u>

<u>所有虚基类的构造函数必须按从左到右、从最深到最浅的顺序被调用。如果虚基类在成员初始化列表中列出，显式指定的参数会传递给虚基类构造函数。如果虚基类没有在成员初始化列表中列出，但有默认构造函数，则默认构造函数会被调用。虚基类子对象的偏移位置必须在运行时可访问。</u>

```cpp
class Point {
public:
Point(float x = 0.0, float y = 0.0);
Point(const Point& other); // 拷贝构造函数
Point& operator=(const Point& other); // 拷贝赋值运算符
virtual ~Point(); // 虚析构函数
virtual float z() { return 0.0; }
protected:
float _x, _y;
};
```

Line 类

```cpp
class Line {
Point _begin, _end;
public:
Line(float x1 = 0.0, float y1 = 0.0, float x2 = 0.0, float y2 = 0.0);
Line(const Point& begin, const Point& end);
void draw();
// ...
};
```

Line 类的构造函数

```cpp
Line::Line(const Point& begin, const Point& end)
:_end(end), _begin(begin){}
```

隐式合成的构造函数和析构函数

编译器会将上述构造函数扩充为：

```cpp
Line* Line::Line(Line* this, const Point& begin, const Point& end) {
    this->_begin.Point::Point(begin);
    this->_end.Point::Point(end);
    return this;
}
```

隐式合成的析构函数：

```cpp
// C++ 伪码：合成出来的 Line destructor
inline void Line::~Line(Line* this) {
    this->_end.Point::~Point();
    this->_begin.Point::~Point();
}
```

隐式合成的拷贝构造函数/拷贝赋值运算符：

```cpp
inline Line& Line::operator=(Line& this, const Line& rhs) {
    this->_begin.Point::operator=(rhs._begin);
    this->_end.Point::operator=(rhs._end);
    return *this;
}
```

自我赋值检查

在用户提供的拷贝赋值运算符中，忘记检查自我赋值（self-assignment）是一个常见的错误。

```cpp
String& String::operator=(const String& rhs){
    if (this == &rhs) return *this; // 检查自我赋值
    delete[] str; // 释放旧资源
    str = new char[strlen(rhs.str) + 1]; // 分配新资源
    strcpy(str, rhs.str); // 拷贝字符串
    return *this;
}
```

编译器在生成拷贝赋值运算符时不会自动添加自我赋值检查。

```cpp
inline Line& Line::operator=(Line& this, const Line& rhs) {
    this->_begin.Point::operator=(rhs._begin);
    this->_end.Point::operator=(rhs._end);
    return *this;
}
```

<h4 id="bf46a480">vptr 初始化语意学</h4>
<u>当定义一个派生类对象时，构造函数的调用顺序是从基类到派生类。每个类的构造函数都会调用其基类的构造函数，直到最顶层的基类构造函数被执行。</u>

<u>每个构造函数都可以调用虚函数。这些虚函数调用会被解析为当前正在构造的类的虚函数版本，而不是最终派生类的版本。当基类构造函数正在执行时，派生类的部分还未被构造，因此虚函数表（vtable）还不能指向派生类的虚函数实现。</u>

**vptr初始化的时机**

在任何操作之前 - 如果vptr在构造函数的任何操作之前被初始化，那么当构造函数尝试调用虚函数时，vptr已经指向了正确的虚函数表。但是，这样做可能会导致在构造函数体中调用的成员初始化列表中的虚函数调用出现问题，因为那时vptr可能还没有被正确设置。

**<u>在基类构造函数调用之后，但在成员初始化列表之前，这是</u>****<u><font style="color:#c21c13;">最常用的策略</font></u>****<font style="color:#c21c13;">。</font>**当基类构造函数执行完毕后，vptr被设置为指向当前类的虚函数表。这样可以确保在成员初始化列表中调用的虚函数是正确的。

如果vptr在构造函数的所有操作之后被初始化，那么在构造函数中调用的任何虚函数都将不会被视为虚函数，而是静态绑定的。这显然不是我们想要的行为。

(基类构造->成员变量初始化->构造函数体的执行）

**（理解）构造函数和初始化列表的先后顺序**

**基类构造**：如果当前类有基类（继承自其他类)，首先调用基类的构造函数。基类的构造函数会按照继承顺序执行(如果是多继承，则按照基类声明的顺序执行)。

**成员变量的初始化**：在基类构造函数执行完毕后，开始初始化当前类的成员变量。成员变量的初始化顺序严格按照它们在类中声明的顺序执行，而不是在成员初始化列表中的顺序。

**构造函数体的执行**：在基类构造和成员变量初始化完成后，才会执行当前类构造函数体中的代码。

```cpp
#include <iostream>
class Base {
public:
Base() {
    std::cout << "Base constructor" << std::endl;
}
};
class Member {
public:
Member() {
    std::cout << "Member constructor" << std::endl;
}
};
class Derived : public Base {
private:
Member m1;
Member m2;
public:
// 成员初始化列表
Derived() : m2(), m1() {  // 注意：初始化顺序与声明顺序一致，与初始化列表顺序无关
    std::cout << "Derived constructor body" << std::endl;
}
};
int main() {
    Derived d;
    return 0;
}
```

<h4 id="cbf14d33">对象复制语意学</h4>
📌

关联知识点：

deleted 

<u>在C++中，当设计一个类并进行对象赋值时，有三种选择：</u>

<u>（1）什么都不做：使用默认行为。</u>

<u>（2）提供一个显式的复制赋值操作符。</u>

<u>（3）显式地拒绝将一个类对象赋值给另一个类对象。</u>

<u>如果要禁止将一个类对象赋值给另一个类对象，可以通过将复制赋值操作符声明为私有(private),并且不提供其定义。这样除了类的成员函数和友元之外，其他地方都不能进行赋值操作。如果某个成员函数或友元试图进行赋值操作，程序在链接时会失败。</u>

（也可以直接用delete，参考？）

<u>如果类中没有虚函数、虚基类、具有复制赋值操作符的成员对象或基类，那么默认的复制赋值操作符会执行逐成员复制(memberwise copy)。对于简单的类(如Point)，默认行为通常是足够的且效率高。</u>

<u>自定义复制赋值操作符</u>

<u>只有在默认行为导致不安全或不正确的行为时，才需要提供自定义的复制赋值操作符。例如，如果类中包含动态分配的资源(如指针)，默认的浅复制可能导致资源泄露或双重释放问题。</u>

（上面这段话和前面重复，需要整理）

继承下的复制赋值操作符

**多重继承**

当类从多个基类继承时，复制赋值操作符需要调用所有基类的复制赋值操作符。

```cpp
class Vertex : virtual public Point {
public:
Vertex(float x = 0.0, float y = 0.0) : Point(x, y), _next(nullptr) {}
Vertex& operator=(const Vertex& v) {
    this->Point::operator=(v); //调用基类的复制赋值操作符
    _next = v._next; //逐成员复制派生类的成员
    return *this;
}
private:
Vertex* _next;
};

class Vertex3d : public Point3d, public Vertex {
public:
Vertex3d(float x = 0.0, float y = 0.0, float z = 0.0) : Point3d(x, y, z), Vertex(x, y) {}
Vertex3d& operator=(const Vertex3d& v) {
    this->Point3d::operator=(v); // 调用 Point3d 的复制赋值操作符
    this->Vertex::operator=(v); // 调用 Vertex 的复制赋值操作符
    return *this;
}
};
```

**虚基类的多次调用**

在虚拟继承的情况下，编译器可能会多次调用虚基类的复制赋值操作符。为了避免这个问题，可以在派生类的复制赋值操作符中显式调用虚基类的复制赋值操作符。（这个地方看不懂）

```cpp
inline Vertex3d& Vertex3d::operator=(const Vertex3d& v) {
    this->Point3d::operator=(v);
    this->Vertex::operator=(v);
    this->Point::operator=(v); // 显式调用虚基类的复制赋值操作符
    return *this;
}
```

建议：避免在虚基类中声明数据成员：可以减少复制赋值操作符的复杂性。

显式调用虚基类的复制赋值操作符：确保虚基类的复制赋值操作符只被调用一次。

结论

_**（1）按位复制（Bitwise Copy）**_

当类的数据成员是简单的POD类型且没有虚函数、虚基类或复杂的继承关系时，按位复制是最高效的。

使用公开数据成员的结构体或类，通过显式的初始化列表进行初始化和拷贝操作，性能最佳。

_**（2）封装和内联构造函数**_

封装数据成员并使用内联构造函数会导致 slight overhead，因为内联构造函数的扩展带来了额外的指令。尽管有轻微的性能损失，但封装提供了更好的封装性和维护性，值得在大多数情况下使用。

_**（3）单一继承和多重继承**_

单一继承和多重继承在不引入虚函数和虚基类的情况下，对性能的影响不大，因为仍然支持按位复制语意。

_**（4）虚拟继承**_

虚拟继承显著降低了性能，因为不再支持按位复制语意，编译器生成的内联复制构造函数和复制赋值操作符增加了额外的开销。<u>虚拟继承适用于需要解决菱形继承问题的场景，但在性能敏感的应用中应谨慎使用。</u>

_**（5）包含虚函数的类**_

<u>包含虚函数的类不再支持按位复制语意，编译器生成的内联复制构造函数和复制赋值操作符增加了开销。</u>如果性能是关键因素，应尽量避免在频繁拷贝的对象中使用虚函数。

<h4 id="944ee1a9">析构函数 </h4>
在C++中，类的析构函数主要用于清理资源，比如释放动态分配的内存、关闭文件等。析构函数是在对象生命周期结束时自动调用的。

**<u>编译器自动生成析构函数的情况</u>**

<u>如果一个类没有定义析构函数，并且它的成员对象或基类也没有析构函数，则编译器不会为该类生成析构函数。这是因为在这种情况下，没有特别的清理工作需要做。</u>

<u>成员对象或基类有析构函数：如果类中的某个成员对象或者基类定义了析构函数，那么编译器会为该类生成一个析构函数，这个析构函数会负责调用成员对象的析构函数以及基类的析构函数。</u>

<u>当销毁一个派生类的对象时，析构函数的调用顺序是从最派生类到基类，最派生类的析构函数被调用。</u>

<u>按照继承层次从下到上，调用每个基类的析构函数。如果存在虚基类，它们的析构函数也会按照适当的顺序被调用。</u>

（整理到上面去）

<h1 id="e42e3e69">执行期语意学</h1>
**<font style="color:#db7800;">什么是离开点？如果有多个离开点会怎么样？</font>**

<h4 id="13d727fa">对象的构造和析构</h4>
一般情况对象的构造和析构通常按照预期的方式进行：

```cpp
{
    Point point;
    //point的构造函数在这里被调用
    //point.Point::Point()
    //point的析构函数在这里被调用
    //point.Point::~Point()
}
```

**<u>多个离开点的情况</u>**

当一个代码块或函数中有多个离开点（例如多个return语句或goto语句）时，析构函数的调用位置会变得更加复杂。析构函数必须在每个离开点之前被调用，以确保对象在离开作用域时被正确销毁。

```cpp
{
    Point point;
    // point的构造函数在这里被调用
    // point.Point::Point()
    switch (int(point.x())) {
        case -1:
            //代码逻辑
            //point的析构函数在这里被调用
            //point.Point::~Point()
            return;
        case 0:
            //代码逻辑
            //point的析构函数在这里被调用
            //point.Point::~Point()
            return;
        case 1:
            // 代码逻辑
            // point的析构函数在这里被调用
            // point.Point::~Point()
            return;
        default:
            // 代码逻辑
            // point的析构函数在这里被调用
            // point.Point::~Point()
            return;
    }
    // point的析构函数在这里被调用
    // point.Point::~Point()
}
```

point的析构函数必须在switch语句的每个return语句之前被调用。此外，即使程序分析结果显示不可能到达代码块的结束处，析构函数仍然会在代码块的结束处被调用。

<u>最佳实践</u>

<u>为了节省不必要的对象构造和析构操作，应该尽可能将对象定义在其使用的地方附近。</u>

<u>例如在检查cache之前定义Point对象是不理想的，因为如果缓存命中，Point对象根本不会被使用。</u>

<u>如果对象在某些条件下不会被使用，那么在这些条件下提前定义对象会导致不必要的构造和析构操作，而且将对象定义在其使用的地方可以使代码更清晰，更容易理解和维护。</u>

<h5 id="45c7b321">全局对象</h5>
C++保证这些对象在main()函数开始之前被构造，并在main()函数结束后被析构。这种构造和析构操作被称为静态初始化和静态内存释放（整理到上面）

```cpp
Matr

ix identity;
int main() {
    // identity 必须在此处被初始化
    Matrix ml = identity;
    return 0;
}
```

identity是一个全局对象，C++保证在main()函数开始之前调用Matrix的构造函数来初始化identity，并在main()函数结束后调用Matrix的析构函数来销毁identity。

**静态初始化和内存释放**

C++程序中的所有全局对象都被放置在程序的数据段(data segment)中。如果显式指定了初始值，对象将被初始化为该值；否则,对象所配置的内存内容为0。

```cpp
int v1 = 1024;
int v2;
```

v1和v2都被配置在数据段中，v1的值为1024，v2的值为0。

虚基类的影响

虚基类的引入增加了静态初始化的复杂性。例如，通过派生类指针访问虚基类子对象的位置在编译时不可知，需要在运行时评估。

静态初始化的缺点

异常处理：静态初始化的对象不能放置在try块内，任何抛出的异常将触发默认的terminate函数。

依赖顺序：控制跨模块静态初始化对象的依赖顺序可能导致复杂性。

<h5 id="35e41f2e">局部静态对象</h5>
局部静态对象具有以下特点：

构造：构造函数必须仅在函数首次被调用时执行一次。

析构：析构函数必须仅在程序结束时执行一次。

```cpp
const Matrix identity() {
    static Matrix mat_identity;
    // ...
    return mat_identity;
}
```

为了确保mat_identity的构造函数仅在identity()函数首次被调用时执行一次，cfront编译器采用了以下策略：引入一个临时对象来保护mat_identity的初始化操作。第一次调用identity()时，临时对象被评估为false，构造函数会被调用，然后临时对象被设置为true。析构函数需要有条件地调用，但只有在mat_identity已经被构造的情况下才调用。为了判断mat_identity是否被构造，可以检查临时对象是否为true。

新的C++标准

C++标准委员会正在考虑改变<u>局部静态对象</u>的析构语义。

**构造：**在需要时构造局部静态对象（例如，每个包含局部静态对象的函数首次被调用时）。

**析构：**以构造的相反顺序销毁局部静态对象。

<u>为了支持新的规则可能需要在运行时维护一个链表来记录所有被构造的局部静态对象，并在程序结束时按相反顺序销毁它们。</u>

<h5 id="48f5ad71">对象数组(Array of Objects)</h5>
对象数组的初始化和析构

```cpp
Point knots[10];
```

初始化：如果Point类没有定义构造函数和析构函数，只需要分配足够的内存来存储10个连续的Point元素。

析构：如果Point类定义了默认构造函数和默认析构函数，需要在数组的每个元素上调用构造函数和析构函数。

初始化过程

无构造函数和析构函数的情况

如果Point类没有定义构造函数和析构函数，只需要分配足够的内存来存储10个连续的Point元素。

```cpp
Point knots[10];
```

有构造函数和析构函数的情况

如果Point类定义了默认构造函数和默认析构函数，需要在数组的每个元素上调用构造函数。

vec_new函数

```cpp
void* vec_new(
void* array,          // 数组起始地址
size_t elem_size,     // 每个类对象的大小
int elem_count,       // 数组中的元素个数
void (*constructor)(void*), // 构造函数指针
void (*destructor)(void*, char) // 析构函数指针
);
```

假设Point类定义了默认构造函数和默认析构函数，编译器可能会生成以下vec_new调用：

```cpp
Point knots[10];
vec_new(&knots, sizeof(Point), 10, &Point::Point, 0);
```

析构过程

当knots的生命结束时，需要在数组的每个元素上调用析构函数。这通常通过一个类似的vec_delete（或vec_vdelete，如果类包含虚基类）的运行时库函数来完成。

vec_delete函数

```cpp
void* vec_delete(
void* array,          // 数组起始地址
size_t elem_size,     // 每个类对象的大小
int elem_count,       // 数组中的元素个数
void (*destructor)(void*, char) // 析构函数指针
);
```

假设Point类定义了默认析构函数，编译器可能会生成以下vec_delete调用：

```cpp
vec_delete(&knots,sizeof(Point),10,&Point::~Point);
```

显式初始化的数组

如果程序员提供了一个或多个显式初值给一个由类对象组成的数组，情况会有所不同。

```cpp
Point knots[10] = {
Point(),
Point(1.0, 1.0, 0.5),
Point(-1.0, 0.0, 0.0)
};
```

对于显式初始化的元素，vec_new不再必要。对于未初始化的元素，vec_new的调用方式与未提供显式初始化列表的数组相同。

```cpp
Point knots[10];
// C++ 伪码
// 显式地初始化前 3 个元素
Point::Point(&knots[0]);
Point::Point(&knots[1], 1.0, 1.0, 0.5);
Point::Point(&knots[2], -1.0, 0.0, 0.0);
// 以 vec_new 初始化剩下的 7 个元素
vec_new(&knots[3], sizeof(Point), 7, &Point::Point, 0);
```

<h4 id="4483a855">new 和 delete 运算符</h4>
**使用new运算符来创建一个新的对象：**

（1）内存分配：new首先调用operator new函数（通常是全局的）来分配足够的内存来存放对象。

（2）对象初始化：一旦内存被成功分配，new接着调用对象的构造函数来初始化这块内存。

如果构造函数抛出了异常，那么new会确保已经分配的内存被释放。

**delete运算符负责清理之前由new分配的内存：**

（1）调用析构函数：delete首先调用对象的析构函数来清理对象。

（2）释放内存：接着，它调用operator delete函数来释放内存。

如果指针是nullptr，delete不会执行任何操作。

**自定义new和delete操作：**

可以自定义new和delete操作符来改变内存管理的行为，比如设置自己的内存分配策略或者错误处理机制。

```cpp
void* operator new(size_t size) {
    if (size == 0) size = 1;  // 至少分配1字节
    void* last_alloc;
    while (!(last_alloc = malloc(size))) {
        // 可以在这里添加自己的内存不足处理逻辑
        if (_new_handler) {
            (*_new_handler)();
        } else {
            return nullptr;  // 或者抛出异常
        }
    }
    return last_alloc;
}
void operator delete(void* ptr) noexcept {
    if (ptr) {
        free(ptr);
    }
}
```

<h5 id="2b462807">**针对数组的 new语意**</h5>
_**数组的new语义**_

当使用new运算符来创建一个数组时

```cpp
int *p_array = new int[5];
```

这行代码实际上做了以下几件事情：

内存分配：分配足够的内存来容纳5个整数。

构造：对于基本类型，不需要调用构造函数，但对于用户定义的类型，每个元素都会调用相应的构造函数。如果数组元素是用户定义的类类型，且该类有构造函数，那么每个元素都会调用构造函数。

```cpp
Point3d *p_array = new Point3d[10];  // 创建一个Point3d对象的数组
```

new运算符不仅分配了内存，还会为每个Point3d对象调用构造函数。这通常会调用一个内部函数vec_new，它负责分配内存并调用每个元素的构造函数。

_**数组的delete语义**_

当使用delete[ ] 来释放数组时

```cpp
delete[] p_array; // 释放 Point3d 对象数组
```

析构：对于每个元素，调用相应的析构函数。

内存释放：释放分配给数组的内存。

如果数组元素是用户定义的类类型，且该类有析构函数，那么每个元素都会调用析构函数。这通常会调用一个内部函数vec_delete，它负责调用每个元素的析构函数并释放内存。

（1）构造函数：用于初始化对象。对于数组中的每个元素，构造函数都会被调用。

（2）析构函数：用于清理对象。对于数组中的每个元素，析构函数都会被调用。

（3）特殊情况：基类指针指向派生类数组

如果有一个基类Point和一个派生类Point3d，并且使用基类指针来指向派生类对象数组，那么在删除数组时可能会遇到问题。

```cpp
Point *ptr = new Point3d[10];  // 使用基类指针指向派生类数组
```

在这种情况下，如果你直接使用delete[] ptr;，那么只会调用Point类的析构函数，而不会调用Point3d类的析构函数。此外，由于Point3d对象比Point对象大，析构函数可能会访问超出Point对象范围的内存，从而导致未定义行为。

解决方案

为了避免这种情况，你应该手动遍历数组并对每个元素调用delete，以确保正确的析构函数被调用。例如：

```cpp
for (int i = 0; i < 10; ++i) {
    Point3d *p = &((Point3d*)ptr)[i];
    p->~Point3d();  // 显式调用析构函数
}
operator delete[](ptr);  // 释放内存
```

或者更简单地，直接使用派生类指针来管理数组：

```cpp
Point3d *ptr = new Point3d[10];  // 使用派生类指针
// 使用完毕后
delete[] ptr;  // 正确地调用Point3d的析构函数
```

虚析构函数允许在通过基类指针删除派生类对象时，调用正确的派生类析构函数。这对于单个对象的删除是非常有用的。

```cpp
Point* p = new Point3d;  // 使用基类指针指向派生类对象
delete p;  // 正确地调用 Point3d 的析构函数
```

Point类的析构函数是虚函数，所以在删除Point3d对象时，会调用Point3d的析构函数，而不是只调用Point的析构函数。然而，处理的是一个数组时，即使析构函数是虚函数，delete[]仍然不会按预期工作。

数组删除的特殊性：delete[]期望数组中的所有元素都是同一种类型。它会根据基类指针的类型来确定每个元素的大小，并且只会调用基类的析构函数。

如果派生类对象比基类对象大，delete[]只会按照基类对象的大小来计算数组的总大小。这会导致内存访问越界，从而引发未定义行为。

```cpp
int main() {
    Point* ptr = new Point3d[10];  // 使用基类指针指向派生类数组
    delete[] ptr;  // 错误：只会调用 Point 的析构函数，且可能导致内存访问越界
}
```

delete[]会按照Point对象的大小来计算数组的总大小，如果Point3d对象比Point对象大，那么delete[]会访问超出分配内存的范围，从而导致未定义行为。

<h5 id="fb8b09c3">Placement Operator new 的语意</h5>
placement new 是一种特殊的new运算符，它接受一个额外的void*参数，该参数指向已经分配好的内存。placement new 的主要用途是在特定的内存位置上构造对象，而不是分配新的内存。

```cpp
void* operator new(size_t, void* ptr) {
    return ptr;
}
char memory[sizeof(Point2w)];  // 预先分配的内存
Point2w* ptw = new (memory) Point2w;  // 在预分配的内存上构造Point2w对象
```

placement new 的作用不仅仅是返回一个指针，更重要的是它会调用对象的构造函数。

```cpp
// C++ 伪码
Point2w* ptw = (Point2w*)memory;
if (ptw != 0) {
    ptw->Point2w::Point2w();  // 调用构造函数
}
```

使用placement new时的注意事项

1. 析构函数的调用

如果你在一个已经存在的对象上构造新的对象，而旧对象有析构函数，那么析构函数不会自动被调用。你需要手动调用析构函数。

```cpp
void fooBar() {
    Point2w* p2w = new (arena) Point2w;
    // ... do something ...
    p2w->~Point2w();  // 显式调用析构函数
    p2w = new (arena) Point2w;  // 重新构造对象
}
```

2. arena指针的真实类型

arena指针应该指向一个足够大的内存块，以容纳要构造的对象。这个内存块可以是静态分配的，也可以是动态分配的。

```cpp
动态分配
char* arena = new char[sizeof(Point2w)];  // 动态分配内存
Point2w* ptw = new (arena) Point2w;  // 在预分配的内存上构造对象
静态分配
char arena[sizeof(Point2w)];  // 静态分配内存
Point2w* ptw = new (arena) Point2w;  // 在预分配的内存上构造对象
```

3. 不支持多态

placement new 不支持多态。也就是说，你不应该在基类的内存上构造派生类的对象，因为这可能会导致内存越界或其他未定义行为。

```cpp
错误的用法
Point2w* arena = new Point2w;  // 基类对象
Point2w* p2w = new (arena) Point3w;  // 错误：派生类比基类大
```

4. 虚函数的调用

在placement new的情况下，虚函数的调用可能会出现问题。

```cpp
struct Base {
int j;
virtual void f() { /* ... */ }
virtual ~Base() {}
};
struct Derived : Base {
void f() override { /* ... */ }
};
void fooBar() {
    Base b;
    b.f();  // 调用Base::f()
    b.~Base();  // 显式调用析构函数
    new (&b) Derived;  // 在b的位置上构造Derived对象
    b.f();  // 哪一个f()被调用？
}
```

在这个例子中，b.f()的调用结果是不确定的。尽管Derived对象已经在b的位置上构造，但由于虚函数表可能没有更新，大多数编译器仍然会调用Base::f()。

<h4 id="25f5b935">临时性对象(Temporary Objects)</h4>
```cpp
T a, b；
T c = a + b；
```

a + b可能会创建一个临时对象来存储 operator+ 的返回值。然后这个临时对象会被用来初始化 c。然而，现代编译器通常会进行优化，比如返回值优化（Return Value Optimization, RVO）或命名返回值优化（Named Return Value Optimization, NRVO)，从而避免创建临时对象。

**RVO/NRVO:** 如果 operator+ 返回一个 T 类型的对象，并且这个对象可以直接构造在 c 的位置，编译器可以省略临时对象的创建，这不会调用额外的复制构造函数和析构函数。

**Copy Elision: **即使没有RVO/NRVO，编译器也可以通过复制省略（Copy Elision）来避免临时对象的创建。在这种情况下，a + b 的结果可以直接构造到 c 中。

**临时对象的生命周期**

临时对象的生命周期至少持续到包含它的完整表达式结束。

```cpp
if (s + t || u + v) {
    // ...
}
```

s+t 和u+v都会创建临时对象。u + v 的临时对象只会在 s + t 为假时创建，并且它的生命周期会持续到整个条件表达式结束。 

C++标准明确规定了临时对象的生命周期，确保了跨编译器的一致性。临时对象的生命周期至少持续到包含它的完整表达式结束，即使在条件表达式中也是如此。

假设有一个 String 类，并且定义了 operator+ 和 operator const char*()：

```cpp
class String {
public:
String(const char* str) {/* ... */}
String operator+(const String& other) const { /* ... */ }
operator const char*() const { return _str; }
private:
char* _str;
};
String s("hello"),t("world");
printf("%s\n",s+t);
```

s + t 会创建一个临时对象，这个临时对象会被转换为 const char* 并传递给 printf。根据C++标准，这个临时对象的生命周期会持续到 printf 调用完成。

临**时对象的生命周期规则**

临时对象的生命周期通常至少持续到包含它的完整表达式结束。有两个例外情况：

（1）初始化对象时的临时对象生命周期：当一个表达式用于初始化一个对象时，临时对象的生命周期可能会有所不同。

```cpp
bool verbose;
String progNameVersion = verbose ? "" : progName + progVersion;
```

在这个例子中，progName + progVersion 会产生一个临时对象。根据 verbose 的值，这个临时对象可能会被用来初始化 progNameVersion。如果 verbose 为 false，临时对象将被用来初始化 progNameVersion。临时对象必须在 ?: 表达式评估完成后尽快被销毁。

如果 progNameVersion 的初始化需要调用复制构造函数（copy constructor），临时对象的销毁时间就会变得复杂。根据C++标准，即使在 ?: 表达式结束后，临时对象也必须保持存活，直到 progNameVersion 的初始化完成。

```cpp
if (!verbose) {
    String temp = operator+(progName, progVersion);
    progNameVersion.String::String(temp);  // 复制构造函数
    // 临时对象 temp 应该在 progNameVersion 初始化完成后被销毁
}
```

临时对象被引用绑定时的生命周期：

当一个临时对象被一个引用绑定时，临时对象的生命周期会延长，直到引用的生命结束或临时对象的作用域结束。

```cpp
const String& space = "";
```

在这个例子中，临时对象 "" 会被绑定到引用 space，并且临时对象的生命周期会延长到 space 的生命周期结束。

生命周期规则：

临时对象的生命周期会延长，直到引用 space 的生命周期结束或临时对象的作用域结束，以先到达者为准。

// C++ 伪码

```cpp
String temp;
temp.String::String("");  // 临时对象的构造
const String& space = temp;  // 临时对象被引用绑定
// 临时对象 temp 的生命周期延长到 space 的生命周期结束
if (!verbose) {
    String temp = operator+(progName, progVersion);  // 临时对象的构造
    progNameVersion.String::String(temp);  // 复制构造函数
    // 临时对象 temp 在 progNameVersion 初始化完成后被销毁
}
```

**总结**

初始化对象时的临时对象生命周期：临时对象的生命周期会延长，直到对象的初始化完成。

临时对象被引用绑定时的生命周期：临时对象的生命周期会延长，直到引用的生命结束或临时对象的作用域结束，以先到达者为准。

这些规则确保了临时对象在需要的时候保持存活，避免了未定义行为和潜在的错误。

<h1 id="9416e3be">站在对象模型的尖端</h1>
<h4 id="template">Template</h4>
模板可以编写泛型代码。模板不仅可以用来创建通用的容器和算法，还可以用于实现复杂的编译时计算，比如模板元编程。

尽管模板提供了极大的灵活性和性能优势，但它们也可能导致一系列的问题，以理解的编译错误信息、较长的编译时间、程序尺寸膨胀等。

_**1. 模板的声明**_

当声明一个模板类或模板成员函数时，实际上是在告诉编译器如何根据不同的类型参数生成具体的类或函数。

```cpp
template <typename T>
class Box {
T value;
public:
Box(T v) : value(v) {}
T getValue() { return value; }
};
```

Box是一个模板类，可以用来创建不同类型T的具体Box类。

_**2. 模板的实例化**_

当模板被实际使用时，编译器会根据提供的类型参数来实例化模板。

```cpp
Box<int> myIntBox(10); // 创建一个int类型的Box
Box<double> myDoubleBox(7.8); // 创建一个double类型的Box
```

静态成员和枚举

模板类中的静态成员和枚举需要通过特定类型的模板实例来访问。

如果Box类有一个静态成员count

```cpp
Box<int>::count = ½; // 正确
// Box::count = ½; // 错误，需要指定类型
```

如果Box类有一个枚举Color，也需要通过特定类型的模板实例来访问枚举值。

```cpp
Box<int>::Color color = Box<int>::Color::Red; // 正确
// Box::Color color = Box::Color::Red; // 错误
```

指针和引用

声明一个指向模板类的指针不会导致模板的实例化，因为指针只是存储地址，并不包含模板类的数据。但是，如果创建了一个模板类的引用，或者直接创建了模板类的对象，那么编译器就需要实例化该模板。

```cpp
Box<int> *p; //不会导致实例化
const Box<int>& ref = Box<int>(20); //会导致实例化
Box<int> obj(30); //会导致实例化
```

成员函数的实例化

只有当模板类的成员函数被实际调用时，它们才会被实例化。这意味着如果一个模板类有很多成员函数，但只使用了少数几个，那么只有那些被使用的函数会被编译器实例化，从而节省了编译时间和最终的二进制大小。

<h5 id="23c0a1a7">Template的错误报告</h5>
（1）词法和语法错误：编译器可以在处理模板声明时立即捕捉到词法（如非法字符 $）和语法（如连续的标识符 ex ex 和缺少分号）错误。

（2）类型相关错误：对于类型相关的错误，如默认参数的类型不匹配（第5行）或运算符未定义（第8行），这些错误只有在模板被实例化时才会被检测到。例如，当尝试实例化 Mumble<int> 或 Mumble<int*> 时，编译器会进行类型检查，并在那时报告错误。

（3）成员引用错误：对于成员引用错误，如引用了不存在的成员变量或成员函数，这些错误通常在模板实例化时被发现。如果编译器采用延迟解析策略，那么这些错误直到模板实例化时才会被报告。

编译器策略

（1）完全解析但不做类型检验：一些早期的编译器，如cfront，会对模板进行完全的语法解析，但不会进行类型检验，直到模板被实例化时才进行类型检查。

（2）延迟解析：另一种常见的策略是将模板声明转化为一系列词法记号（tokens），并在实际的模板实例化时再进行解析和类型检验。这种方法可以减少不必要的前期处理，但在模板实例化前不会发现类型相关的错误。

<h5 id="d50f7d66">Template 中的名称决议法(Name Resolution within a Template)</h5>
名称解析在模板中的作用

在C++中模板名称解析涉及两个不同的作用域：模板定义的作用域和模板实例化的作用域。

类型无关的名称解析：如果名称的使用不依赖于模板参数，编译器会在模板定义的作用域中解析该名称。

类型相关的名称解析：如果名称的使用依赖于模板参数，编译器会在模板实例化的作用域中解析该名称。

<h5 id="965bdd2a">成员函数的实例化行为</h5>
C++模板成员函数的实例化是一个复杂的过程，编译器需要解决几个问题：

_**1. 编译器如何找到函数定义？**_

（1）包含模板程序文本文件：类似于头文件的处理方式，将模板定义包含在每个需要使用的源文件中。

（2）文件命名规则：规定模板定义必须存在于特定命名的文件中，如果在 Point.h 中声明了模板函数，那么其定义必须在 Point.C 或 Point.cpp 中。cfront 编译器采用了这种策略。

（3）混合策略：一些编译器如 Edison Design Group 编译器支持上述两种策略。

_**2. 如何仅实例化程序中使用的成员函数？**_

（1）全实例化：生成所有成员函数的实例，即使有些函数从未被使用。Borland 编译器采取了这种策略，但提供了 #pragma 指令来控制实例化。

（2）按需实例化：通过模拟链接过程，仅生成实际需要的成员函数实例。cfront 编译器采用了这种方法，而 Edison Design Group 编译器支持两种策略。

_**3. 如何防止成员定义在多个目标文件中被多次实例化？**_

.....

<h4 id="b8a0560e">异常处理(Exception Handling)</h4>
C++的异常处理由三个主要组成部分构成：throw表达式、catch子句和try块。当异常被抛出时，程序控制权会转移，并且会沿着调用堆栈回溯，直到找到匹配的catch子句。在此过程中，局部对象的析构函数会被调用，称为"堆栈展开"(stack unwinding）的过程。

<h5 id="6690753c">**异常处理的支持**</h5>
当异常发生时，编译系统需要做：

（1）检验发生throw操作的函数：确定抛出异常的函数。

（2）决定throw操作是否发生在try区段中：判断异常是否在try块中抛出。

如果异常在try块中抛出，编译系统会将异常类型与每一个catch子句进行比较。如果找到匹配的catch子句，控制权转移到该catch子句。

如果throw不在try块中，或者没有匹配的catch子句，编译系统会：

（1）摧毁所有活动的局部对象。

摧毁所有局部对象意味着在当前函数调用栈帧中，所有具有析构函数的局部对象将被销毁。析构函数通常用于释放对象占用的资源，如关闭文件、释放内存、断开网络连接等。在异常处理过程中，确保这些资源被正确释放是非常重要的，以避免资源泄漏。

（2）继续到堆栈中的下一个函数，并重复上述步骤2-5。

确定throw是否发生在try区段中，一个函数可以分为几个区域：

try区段外，没有需要析构的活动局部对象。try区段外，但有一个或多个需要析构的活动局部对象。try区段内。编译器通过构建一个程序计数器范围表来标识这些区域。当异常抛出时，当前的程序计数器值与范围表进行比较，以确定异常是否在try块中。

**异常类型的比较**

对于每个抛出的异常，编译器会生成一个类型描述符，其中包含异常类型的编码信息。如果异常类型是派生类型，描述符中还会包含所有基类的类型信息，包括私有和保护基类。编译器还为每个catch子句生成一个类型描述符。运行时异常处理器会将抛出对象的类型描述符与每个catch子句的类型描述符进行比较，直到找到匹配的catch子句或堆栈被完全展开。

**异常对象的生命周期**

当异常对象在运行时被抛出时，会发生以下过程：

异常对象被创建并通常放在一个特殊的异常数据堆栈中。传递给catch子句的是异常对象的地址、类型描述符（或一个返回类型描述符的函数指针）以及可能的异常对象描述符。

catch子句中的异常对象

考虑以下catch子句

```cpp
catch(exPoint p) {
    // do something
    throw;
}
```

如果异常对象的类型是exVertex，派生自exPoint，那么这个catch子句会匹配。在这种情况下，p会发生以下变化：p会被初始化为异常对象的副本，就像函数参数一样。如果exPoint有复制构造函数和析构函数，它们会应用于p。由于p是一个对象而不是引用，复制时会进行切片（slicing），即只复制exPoint部分，丢弃exVertex特有的部分。此外，p的虚函数表指针（vptr）会被设置为exPoint的虚函数表。当再次抛出异常时，会创建一个新的临时对象，而不是使用原来的exVertex对象。原来的异常对象会被再次抛出，对p的修改会被丢弃。

如果catch子句是引用类型：

```cpp
catch(exPoint &p) {
    // do something
    throw;
}
```

在这种情况下，p是原始异常对象的引用，任何虚函数调用都会基于exVertex的实际类型，对p的修改会传递到下一个catch子句。

异常处理机制要求编译器跟踪每个函数的作用域，以便在抛出异常时能够找到匹配的catch子句来处理异常。编译器还必须提供查询异常对象类型的方法（RTTI），并且管理被抛出的对象，包括其创建、销毁和清理。假设有一个基类 BaseException 和一个派生类 DerivedException，并且我们希望在抛出DerivedException 时，能够用 BaseException 类型的 catch 子句来捕获它。

**异常对象的类型识别（RTTI）**

```cpp
#include <iostream>
#include <typeinfo>
class BaseException {
public:
virtual ~BaseException() {}
};
class DerivedException : public BaseException {
public:
~DerivedException() override {}
};
void someFunction() {
    try {
        // 抛出一个 DerivedException 对象
        throw DerivedException();
    } catch (const BaseException& e) {
        // 使用 typeid 来检查异常的实际类型
        if (typeid(e) == typeid(DerivedException)) {
            std::cout << "Caught a DerivedException" << std::endl;
        } else {
            std::cout << "Caught a BaseException" << std::endl;
        }
    }
}
int main() {
    someFunction();
    return 0;
}
```

抛出一个 DerivedException 对象。由于 BaseException 是 DerivedException 的基类，我们可以使用 BaseException 类型的引用作为 catch 子句的参数来捕获这个异常。然后，我们使用 typeid 操作符来检查捕获到的异常对象的实际类型。如果异常对象是 DerivedException 类型，程序会输出 "Caught a DerivedException"；否则，输出 "Caught a BaseException"。

当执行 throw DerivedException(); 语句时，一个 DerivedException 对象被创建。这个对象是一个临时对象，它被创建在堆栈上或者堆上，具体取决于编译器的实现。抛出的 DerivedException 对象需要被存储起来，直到找到合适的 catch 子句。在存储期间，对象的生命周期由异常处理机制来维护。

当异常对象被传递给 catch (const BaseException& e) 时，它并没有立即被销毁。只有当 catch 块执行完毕时，异常对象才会被销毁。如果在 catch 块内部再次抛出异常（例如 throw或者 throw e），那么原始的异常对象会被复制，并且新的副本会被传递给下一个匹配的 catch 子句。原始对象仍然会在当前 catch 块结束时被销毁。如果 DerivedException 对象包含需要特别清理的资源（比如文件句柄或网络连接），这些资源会在对象的析构函数中被释放。例如，如果我们给 DerivedException 添加一个析构函数来关闭文件句柄，那么当 DerivedException 对象被销毁时，文件句柄就会被关闭。

当一个异常被抛出时，异常处理机制需要确定异常对象的实际类型，这样才能找到匹配的catch子句。C++提供了typeid操作符和dynamic_cast，这些都是基于RTTI的特性。通过RTTI，编译器能够在运行时检查异常对象的类型，从而决定应该执行哪个catch块。

**异常对象的生命周期管理**

异常对象在抛出时被创建，在找到匹配的catch子句后被销毁。编译器需要负责确保异常对象在整个异常处理过程中得到正确的管理。

当throw表达式被执行时，一个新的异常对象会被创建，这个对象通常是一个临时对象。异常对象需要被存储，直到找到合适的catch子句。这个存储位置可能是堆栈或堆，取决于编译器的实现。一旦异常对象被传递给catch子句，它将在catch块结束时被销毁。如果catch子句中有throw语句来重新抛出异常，那么原来的异常对象会被复制，新的副本将被传递给下一个catch子句。如果异常对象包含了需要特殊清理的资源（如文件句柄或网络连接），那么在对象被销毁时，这些资源需要被正确地释放。这通常是通过对象的析构函数来完成的。

异常处理可能对程序大小和执行速度产生影响。编译器可以选择在编译时或运行时构建支持异常处理所需的数据结构。编译时构建可以提高执行速度但可能增加程序大小，运行时构建则相反。

1. 在编译时构建的情况下，编译器会在编译阶段生成一个异常处理表，这个表包含了关于每个try-catch块的信息，比如它们在代码中的位置、哪些异常类型可以被捕获等。这样，当异常发生时，编译器可以非常快速地查找这个表来决定如何处理异常。
2. 编译器会动态地构建异常处理信息,它可能会创建一个临时的数据结构，记录当前的调用堆栈和异常类型。然后，这个数据结构会被用来搜索匹配的catch块。如果找到了匹配的catch块，异常对象会被传递给它；如果没有找到匹配的catch块，则会继续向上搜索调用堆栈，直到找到一个匹配的catch块或到达顶层调用。

对于一些看似简单的函数，异常处理也带来了额外的复杂性。

当一个异常抛出时，函数可能需要确保某些资源被正确释放，如锁定的内存等。文章还提供了几种编写异常安全代码的技术，比如使用智能指针auto_ptr来自动管理动态分配的内存，或者封装资源获取和释放逻辑到类的构造函数和析构函数中。

```cpp
// 原始的mumble函数，没有异常处理
Point* mumble() {
    Point *pt1, *pt2;
    pt1 = foo();
    if (!pt1) return 0;
    Point p; // 局部对象
    pt2 = foo();
    if (!pt2) return pt1;
    // ... 其他代码
    return pt2;
}
// 添加了异常处理的mumble函数
void mumble(void *arena) {
    Point *p = new Point;
    smLock(arena); // 锁定内存
    // ... 其他代码
    smUnlock(arena); // 解锁内存
    delete p;
}
// 使用try-catch块使mumble函数异常安全
void mumble(void *arena) {
    Point *p;
    p = new Point;
    try {
        smLock(arena);
        // ... 其他代码
    } catch (...) {
        smUnlock(arena);
        delete p;
        throw; // 重新抛出异常
    }
    smUnlock(arena);
    delete p;
}

//使用智能指针和封装资源管理的mumble函数
void mumble(void *arena) {
    std::auto_ptr<Point> p(new Point);
    SMLock sm(arena); // 封装了锁的类
    // 不需要显式的解锁和删除
}
```

原始的 mumble 函数，没有异常处理。如果 foo() 抛出异常，那么 mumble 函数将直接终止，而不会释放任何已分配的资源。此外局部对象 p 会在函数退出时自动销毁，但如果在 p 的构造过程中抛出异常，函数会直接退出，不会执行后续的代码。

添加异常处理的mumble函数

```cpp
void mumble(void *arena) {
    Point *p = new Point;
    smLock(arena); // 锁定内存
    // ... 其他代码
    smUnlock(arena); // 解锁内存
    delete p;
}
```

该函数创建了一个 Point 对象，锁定了一块内存（arena），执行一些其他代码，然后解锁内存并删除 Point 对象。

使用 try-catch 块来确保在抛出异常时，smUnlock 和 delete p 仍然会被执行。如果在 try 块中的代码抛出异常，catch 块会解锁内存并删除 Point 对象，然后重新抛出异常。如果 try 块中的代码没有抛出异常，smUnlock 和 delete p 会在 try 块结束后正常执行。

使用智能指针和封装资源管理的 mumble 函数

```cpp
void mumble(void *arena) {
    std::auto_ptr<Point> p(new Point);
    SMLock sm(arena); // 封装了锁的类
    // 不需要显式的解锁和删除
}
```

auto_ptr 会在离开作用域时自动删除 Point 对象，即使在构造 Point 对象或执行其他代码时抛出异常。SMLock 类会在构造函数中锁定内存，在析构函数中解锁内存，这样即使在 try 块中的代码抛出异常，锁也会被正确地解锁。方法利用了RAII原则，确保资源在对象生命周期内得到正确管理。

<h4 id="49dbde5f">执行期类型识别(Runtime Type Identification,RTTI)</h4>
运行时类型识别（RTTI）允许程序员查询对象的实际类型，以及将基类的指针或引用转换为派生类的指针或引用。

```cpp
#include <typeinfo>  // 用于 typeid 和 dynamic_cast
//基类
class type {
public:
virtual ~type() {}  // 虚析构函数，确保派生类能够正确销毁
virtual void call() = 0;  // 纯虚函数，使 type 成为抽象类
};
// 单一函数类型
class fct : public type {
public:
void call() override {
    std::cout << "fct::call()" << std::endl;
}
};
// 可以被重载的函数类型
class gen : public type {
public:
void call() override {
    std::cout << "gen::call() - non-const" << std::endl;
}
void call() const override {
    std::cout << "gen::call() - const" << std::endl;
}
};
int main() {
    // 创建 type* 指针，并让它指向 fct 对象
    type* typePtr1 = new fct();
    // 创建 type* 指针，并让它指向 gen 对象
    type* typePtr2 = new gen();
    // 尝试将 type* 转换为 fct*
    fct* fctPtr1 = dynamic_cast<fct*>(typePtr1);
    if (fctPtr1) {
        fctPtr1->call();  // 安全地调用 fct::call()
    } else {
        std::cout << "typePtr1 is not a fct" << std::endl;
    }
    // 尝试将 type* 转换为 fct*，但实际上是 gen
    fct* fctPtr2 = dynamic_cast<fct*>(typePtr2);
    if (fctPtr2) {
        fctPtr2->call();  // 如果转换成功，调用 fct::call()
    } else {
        std::cout << "typePtr2 is not a fct, it's actually a gen" << std::endl;
    }
    // 清理资源
    delete typePtr1;
    delete typePtr2;
    return 0;
}
```

这里的type是所有类型的基类，fct代表单一函数类型，而gen代表可以被重载的函数类型。

当尝试将 type* 指针转换为 fct* 时，如果该指针实际上指向的是 gen 对象，那么使用 static_cast 将导致未定义行为，因为 gen 和 fct 的内存布局可能不同。使用 dynamic_cast 则会在运行时检查实际的对象类型，如果发现类型不匹配，它会返回 nullptr，从而避免了潜在的错误。

dynamic_cast 在运行时检查类型转换的有效性。它使用了 RTTI（运行时类型信息）来确定对象的真实类型。如果转换不安全，dynamic_cast 会返回 nullptr（对于指针）或抛出异常（对于引用）,这使得程序可以在转换失败时采取适当的措施。dynamic_cast 只能用于含有至少一个虚函数的类之间（即多态类型）。这是因为 RTTI 只能应用于这些类。

_**为什么要将基类指针转换为派生类指针？**_

将基类指针转换为派生类指针通常是为了访问派生类特有的成员，这些成员在基类中是不可见或不存在的，基类指针只能访问基类中定义的公共或保护成员。这种转换通常发生在多态场景下，当有一个指向基类的指针，但实际上该指针指向的是派生类的对象。通过向下转型(downcast)，可以利用派生类特有的功能。

在多态设计中，基类指针经常被用来指向派生类对象，以便于编写通用的代码。但在某些情况下，你可能需要知道具体的派生类类型，以便执行特定的操作。

有时候，直接使用派生类指针可以提高性能，尤其是在频繁调用派生类特有的方法时，直接访问可以避免虚函数调用带来的额外开销。

```cpp
#include <iostream>
class Shape {
public:
virtual ~Shape(){}
virtual void draw() const = 0;  // 纯虚函数，使得 Shape 成为抽象类
};
class Circle : public Shape {
private:
double radius;
public:
Circle(double r) : radius(r) {}
void setRadius(double r) {
    radius = r;
}
void draw() const override {
    std::cout << "Drawing a circle with radius: " << radius << std::endl;
}
};
class Rectangle : public Shape {
private:
double width, height;
public:
Rectangle(double w, double h) : width(w), height(h) {}
void draw() const override {
    std::cout<<"Drawing a rectangle with width: "<< width
        <<" and height: "<< height << std::endl;
}
};
int main() {
    Shape* shape1 = new Circle(5.0);
    Shape* shape2 = new Rectangle(8.0, 9.0);
    // 通过基类指针调用 draw 方法
    shape1->draw();  // 输出圆的信息
    shape2->draw();  // 输出矩形的信息
    // 如果需要设置圆的半径，就需要向下转型
    Circle* circle = dynamic_cast<Circle*>(shape1);
    if (circle) {
        circle->setRadius(½);  // 设置新的半径
        circle->draw();  // 再次绘制，显示更新后的半径
    } else {
        std::cout << "shape1 is not a Circle" << std::endl;
    }
    // 清理资源
    delete shape1;
    delete shape2;
    return 0;
}
```

非法/合法的向下转换

向下转换是合法的，当且仅当基类指针或引用实际上指向的是派生类对象。当基类指针或引用实际指向的是派生类对象时，向下转换是合法的。例如，如果有一个 Base* 指针，但它实际上指向的是 Derived 对象，那么将其转换为 Derived* 是合法的。

在C++中，当一个派生类对象被创建时，它首先包含了所有基类的数据成员。这意味着派生类对象的内存布局开始于基类部分，然后是派生类特有的部分。因此，一个指向基类部分的指针实际上也是指向整个派生类对象的起始位置。

当创建一个 Derived 对象时，内存布局如下：

+-----------------+

| Base::baseData | <- Base* 指向这里

+-----------------+

| Derived::data |

+-----------------+

一个 Base* 指针实际上可以用来访问整个 Derived 对象，只是通过这个指针只能访问 Base 部分的成员。如果我们将 Base* 向下转换为 Derived*，就可以访问 Derived 特有的成员。

如果基类指针或引用实际指向的是基类对象本身，而不是派生类对象，那么将其转换为派生类指针或引用是非法的。这会导致未定义行为。

使用 static_cast 或 C 风格的强制类型转换：static_cast 和 C 风格的强制类型转换（如(Derived*)basePtr）不会进行运行时类型检查。如果转换不合法，它们不会提供任何保护，可能会导致未定义行为。

使用 dynamic_cast：在不确定基类指针或引用实际指向哪种派生类对象时，使用 dynamic_cast 进行向下转换。它会在运行时进行类型检查，确保转换的合法性。

**dynamic_cast 的工作原理**

当使用 dynamic_cast 将基类指针或引用转换为派生类指针或引用时，编译器会在运行时检查实际的对象类型是否匹配。如果转换是不可能的(尝试将基类指针转换为一个无关的派生类)，dynamic_cast 会返回 nullptr 对于指针，或者抛出 std::bad_cast 异常对于引用。

为了实现 dynamic_cast，C++ 使用了 RTTI 机制。RTTI 允许程序在运行时获取对象的类型信息。每个包含虚函数的类（即多态类）都有一个类型信息对象 (type_info)，并且这个对象的指针通常被存储在虚函数表（vtable）的第一个槽位。

dynamic_cast 的成本

（1）空间成本：每个具有虚函数的类实例都会有一个额外的指针（通常是 vptr），它指向虚函数表。虚函数表的第一个槽位存放的是指向 type_info 对象的指针。

（2）时间成本：在执行 dynamic_cast 时，需要访问 vptr 来找到 type_info，然后与目标类型的 type_info 进行比较。这是一个运行时操作，比 static_cast 更加昂贵。

dynamic_cast 与引用

引用与指针的一个关键区别在于引用必须总是引用一个有效的对象，不能像指针那样可以为空（nullptr）。因此，当 dynamic_cast 应用于引用时，它不能返回 nullptr 来表示转换失败。相反，如果转换不安全，dynamic_cast 会抛出一个 std::bad_cast 异常。

```cpp
Base& baseRef = getSomeBaseReference();  // 假设这个函数返回一个 Base& 引用
try {
    Derived& derivedRef = dynamic_cast<Derived&>(baseRef);
    // 转换成功，可以安全地使用 derivedRef
} catch (const std::bad_cast& e) {
    // 转换失败，baseRef 不是 Derived 对象的引用
}
```

可以重新实现 simplify_conv_op 函数，使其接受一个引用作为参数，并使用 dynamic_cast 来尝试向下转换。如果转换成功，函数将继续执行；如果转换失败，将捕获 std::bad_cast 异常并处理错误情况。

<h5 id="5e7afa69">TypeID运算符</h5>
typeid 运算符用于获取表达式的类型信息，它可以用于在运行时检查变量或表达式的类型。

typeid 运算符返回一个 const std::type_info 类型的引用，该引用提供了有关类型的详细信息。

std::type_info 是 C++ 标准库中定义的一个类，它提供了关于类型的名称和其他信息。

typeid 运算符的基本用法

typeid(expression)：返回表达式 expression 的类型信息。

typeid(type)：返回类型 type 的类型信息。

std::type_info 类

std::type_info 类提供了以下成员函数：

```cpp
virtual ~type_info();：析构函数。
bool operator==(const type_info& rhs) const;：判断两个 type_info 对象是否相等。
bool operator!=(const type_info& rhs) const;：判断两个 type_info 对象是否不相等。
bool before(const type_info& rhs) const;：比较两个 type_info 对象，用于排序。
const char* name() const;：返回类型的名称。
```

typeid 与多态类和非多态类

typeid 可以用于多态类（包含虚函数的类），在这种情况下，type_info 对象是在运行时确定的。

typeid 也可以用于非多态类（不包含虚函数的类）和内置类型，这种情况下，type_info 对象是在编译时确定的。

```cpp
#include <iostream>
#include <typeinfo>
class Base {
public:
virtual ~Base() {}
};
// 派生类
class Derived : public Base {
public:
void doSomething() {
    std::cout << "Doing something in Derived" << std::endl;
}
};
// 模板类
template <typename T>
class Generic {
public:
T value;
Generic(T val) : value(val) {}
};
// 用于简化类型转换的函数
void simplify_conv_op(const Base& rt) {
    if (typeid(rt) == typeid(Derived)) {
        // 向下转换为 Derived 类型
        Derived& rf = static_cast<Derived&>(rt);
        rf.doSomething();
    } else if (typeid(rt) == typeid(Generic<int>)) {
        // 向下转换为 Generic<int> 类型
        Generic<int>& rg = static_cast<Generic<int>&>(rt);
        std::cout << "Generic<int> value: " << rg.value << std::endl;
    } else {
        // 其他类型的处理
        std::cout << "Unknown type" << std::endl;
    }
}
```

